<html><title>Runekeeper</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  function renderLines(ctx2, lines) {
    ctx2.beginPath();
    lines.map((pt, i) => {
      if (i == 0) {
        ctx2.moveTo(pt[0], pt[1]);
      } else {
        ctx2.lineTo(pt[0], pt[1]);
      }
    });
    ctx2.stroke();
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function arrayRemove(list, valuesToEvict) {
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // ../rune-classifier/base64_encoded_model.txt
  var base64_encoded_model_default = "eJiYiIiJeIiIiXeIiIiXmXl3iXh5iIiHh3eJmXiIl5l3iHd4iIiIh3d4eZeIiIiHiIeJiXeJiIh4mJl3iHl5h5iHiYiIeIeYiIiYmIh3d4iHmIeIh5iJmYmXiIeXh3l4h3mYeXh5iXiIiJeIeJiXd3iYmXeJmId5h4mXd5eJiHiIiJmXeHl5iJiIh4eIiXiXiHiIiId3iIiIl5iIh3mYiYiIiIeHiHmId4h4l3d3d4iIiImJeIiIh4iHiIiYiXiJl5mIiIiJiYiYeHiIiZh4iZd3l5iYd4iIiHiJmZeXmJh4iImZiHh4iZiHiIiZmYd4eIiJh4h4eJh4h3d3eHiJh5d5d4d3iXeIeIiIeImIiYiHl5iIeYh5d4d4iHeIiXeIiHiIh3iHmJiIiIiIiJl4iIeIiIiIiYiImJiYiHh3h3eImZmXh5iIh6iYl3iJiXeIl5h3eZmIeIh4eId3iJl4h4iZeYiJh4iImXiYeHiZeIiJeXeIl5l4mYmYiIiIeIeIiIeHiXh3d4eId4mHmYl4iJiYh5iHeIiYmYiZiHiIiIiIiXmIiYd4h5iHh4h3d4iHiHiIh4h4h3d4iHmIiIiIiJiIh4h5iIeYmZiJiIiXiJmYeJiYiIiHiImHiImYiIl4eHeZiImJeHiImJiYh5h3mHmXeIh4d5h4eJmJiHh4h3iIeId3iYiHh5eXmYmIeImIeJeIh4d4h5mHd5iIiYiJd5eId3iHiIiHl4mIh4eYeIiZmYiHh5mHiJmIl4mId3iHd4iJh4d5l4d3eIh4iIiXiIiIiImIiHmImIh4iHeJiJmJiHiHeId4mHmJiHh4eIiId4l5mIiJiHiJiYiImXd3eIiIiYmIiYmYh4mImImIh3iId4d4d5eYd4iIl5iJh5eHd4eIeYeJl4iYmImJiXeHmYmIiIh4l4l4mJeHiIiId4mXmXeHmHmIiJmYmIiJiYl5iXiHh3eYiId4eIiIh4h4h3h4eIeHeId3h4iHiHh3iHiImImImImZiYiHmJiJiHiIiImId5d3mZeIh5h5h4iHiIiHeJiIiYl4mHiZiZiIiXmIl4mZh4mJiYh4iJiHiYh4iIeYl5eJiIiImImIiYeYiYiIiIeHeIl4h5iFeIiHeId4h4eIiIiIiIiIiImIeIiIeIiIiIiIiJiIiIiIiYiIiIiYeIiIiIiIiImIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiHeIiIeIiHiYeIiIiIiIiIh4h4iJiIiIiIeHiIiIiJiIiIiHiJiIh3iIh3iHiHiIiIeIiIeIiIiIh4iHiJiHeIiIh3eIh4iIh4h3iYiIiIiHiIiIiIiIeIiIeIiIiIiIiIiIiIiIeId4d4eYh3mHh4iHiIh4iIeYiJiIiIeIiYeHiIiHiIiIiIiIeHiJiIeIiIh4eIiHiHiHiIiZiImHmJiIh4iIiIiIh4iIiIiIiIiIeIiIiIiIiHh4mIiJiIiIiIiIiIiJmIiIiIiId4iHiIiIiIiIiJiIiHiIiIh4h4iIiImIiIiIiIh4iImIiIeIiIiIiIiIiIiIiHiIiIh4mIiIiImIiIiIeIh4h4iIh3iIiHmJiHiIiIiHiIh4h4iIiImIiImIiIiIiImIh4iYiJh4iIiImIh4iIiIeIh3iIiIiIiIh4iImIiIiYeIiIeHiIiYeIiIiIiId4iIiIiIiJiIeIiIiYiIiIiIeHiIiJiIeIeHiIh4iIiHiIiIiIiIiIh4iIiHiIiIeIiIiIiIh4eIiHh4iIeHh4h3iJiIiIiIiXd4iIiIeImIiIiIiJiIiIiIiImIiIiIiIiHh4iIiIh4iIiIiYeImImIiIh4eIiJiIiIiJeIiIiIiIiIiIiHiHeIiIiIiIiIiIiIh4iIiYh4h4h4iIiHiIeHeHiIiJiIh3iHmJiIh4iIiIeIh4iHmZmIiYiYh4iIiIiIeImHiIiIiHiImYeIiImIeIh3iHd3mIiIiHiHiImIiIiIiIeIeHeYiIl4iIiHh4iHh4h4iIiIiIiHiHiIeHeYh4iIeIiIiImImIiIiIh4eIiIiYiIiIiIiIiIiIeIiIiIiIiIiIiIiId4iIiJiIiIiIiIiIh4iYiIiIiIiIiIh4iIiJeIiIiIiIiIiIiYiYiJiJiXiIiIiIiIh4iHd5iIiZh5iJiYiIiIiIiIiIiIiHd4iHiIiIiIeJiIiIiIh3iImIiIiIiIiIiIiIiIiIiIh4l4iIiIiIiIiIeJiIiIiJeIiIiIiIiHiIl4eImIiIiIiIiYh3iIiIiIiIiImYeIiIiJiIiIiIiIiIiIiIiIiIeIiId4iYiIiIiIh4iHiIiIiIiImIiIiHiJiImIeIiIiIeImHiIiHiIiIiIiJd5iIiIiIiHiIiIiIiIiIiIiIiIiYiIiIiIiIiIiJiIiYeIiIiIiIiIeImIiIiIiHiIh4iIiIiJmIiIh3iIiIh4iIeIh4iIiIiIeIiIiIiIiIiIiIiIeIh4mIiHeIiYiJh4iIiHiIiIiIiIiHiIiYiIiIiIeIeZh4eHeIiIeIiJh4iIiHiIiIiIiIiIiHiIh3mIiHh4iIh4iJd4iHmIeIiHeIh4iYiIiIiIiImIh4iYiImIiIiJh4h4h4mIeIiHiIh4iIiHiIiIiJh4iIiIiIiYiYd5iIiHiHh4iHiIiIiHiIh4h3h4iIeYh4iIh4iIiHeIiIiIiIiIeIiJh4iIiHiJiIiIiIiIiIiImIeIiIiIiIiIiJiIiIiImIiIiIiIiImIiIiIiIh4iIiIeIiIiIiIh4iIiIh4iIiIiIiIiIiHh4h4iIiIiIiIiIiIeIiIiIiIiIh4iIiIiIiIiIiIiYiIh4eYiHiIiIiIiHiImIiJh4iIiIeJiHiHiIeHiIiIiHiIh4eIh4iHiId3iImHiIiId4iIiJiIeIeIeIiIiIiIiIiIiIiIiIiHiHh4eIiIh4mIiYiIiIiIiImHiIeIiIiHiIiIiJiIeIiIh4eIeIiIeIiHiIiHiIh4iIh4iIiIiXiJiIiImIiHiHiIiIiIh4iJiIiIiHiYiYmIiIiIh4iIiIeIiJiJiIiIiXiIh4h4iHiIh4mXh5iIeIiIiIiHiIiIiIiIeIiIiImIiIiIiIiIiIh4h3iHiHd4iYd4iJiImIiImIiJiIiIiIiIiIiIeJiImHiIiIeHh5iIiIiIiIiIiJiImYmImIl4iImIiJiJiIiIiIiHiJh4iIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIh4iIiIh4h4iHiIiGiIiIiIiIiIiIiIiJiIh4iIiIiIiIh4eIiHeIeIh4h4iJh3h3h4eJiIiIiIh4iIeIiIiIiHiIeImIiIiIiIiIiImYiIeIiIh4iYiIiIiIiHiIeIiIiIiIiIiIiIiXiIiIiIiIeIiIiIh4h3iIiHiYmJiIeIeIiHh2qXmYd4mJmImKd4l4mYmHiWmIl4iHiIe5mIhpmJl4eaiaqZd6aJeZqXh3iYiXaYiHqIqJiZVnenmHaJd3qXd2eZh5mJeYmHZWmXeHiGiZlpmZhomYmml2eJiHtnZ5l4mZiZiIdolpmphnmWd4mKmIhXd5aIh5h5Z6aIiZZqmYh5h3ipandpqXeGqHiZaXdnmYh5l5l4d4qZiXmpipiGeIaIlaeIiZqHmXl5imeYaHiZmHl3eIh3iVipl5aWephnh2eYh4iWiWiHiJeJeHiHh7pZiXiHZ4qWl5aZqZmIhnhoeXmIiWd4eaibaJl3l3Zpl3alh5maiIZ5aGeZh4l4iZiXl3l2eJeYh5h5iJmYmZhmeHhpiKeZlneWead6iXt6eKmXd5mniWeGlnmYiWipeYeFmYZ4eHmXmlaqh2iIiJlplpiJiIl4qYmIdoepiIl4mYp4iYeImIqZaaaIiZh5d3Z4";

  // src/rune-model.js
  var encodedWeights = atob(base64_encoded_model_default);
  var modelParams = [];
  for (let i = 0; i < 0 + 1 * encodedWeights.length; i++) {
    const a = encodedWeights.charCodeAt(i);
    modelParams.push(((a & 15) - 8) * 2.2 / 16, ((a >> 4 & 15) - 8) * 2.2 / 16);
  }
  function linearReluLayer(data, modelParams2, numOutputs, numInputs, x0, y0, span, stride, weightOffset, biasOffset) {
    const outputs = new Array(numOutputs);
    for (let i = 0; i < numOutputs; i++) {
      let acc = 0;
      for (let j = 0; j < numInputs; j++) {
        const inputIndex = y0 + j % span + stride * (x0 + Math.floor(j / span));
        const weightIndex = weightOffset + i * numInputs + j;
        acc += modelParams2[weightIndex] * data[inputIndex];
      }
      const biasIndex = i + biasOffset + weightOffset;
      outputs[i] = Math.max(0, modelParams2[biasIndex] + acc);
    }
    return outputs;
  }
  function layerNorm(t) {
    const mean = t.reduce((acc, val) => acc + val, 0) / t.length;
    const variance = t.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / t.length;
    return t.map((val) => (val - mean) / Math.sqrt(variance + 1e-3));
  }
  function classify(data) {
    const BASE_PATCH = 7 * 7;
    const PATCH_FEATURES = 34;
    const PATCH_FEATURES_DEEP = 25;
    const NUM_CLASSES = 7;
    x11 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x12 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x13 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x14 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x21 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x22 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x23 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x24 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x31 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x32 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x33 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x34 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x41 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x42 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x43 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x44 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    y11 = layerNorm(linearReluLayer(
      x11.concat(x12, x21, x22),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y12 = layerNorm(linearReluLayer(
      x13.concat(x14, x23, x24),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y21 = layerNorm(linearReluLayer(
      x31.concat(x32, x41, x42),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y22 = layerNorm(linearReluLayer(
      x33.concat(x34, x43, x44),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    z = linearReluLayer(
      y11.concat(y12, y21, y22),
      modelParams,
      NUM_CLASSES,
      4 * PATCH_FEATURES_DEEP,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES + 4 * PATCH_FEATURES * PATCH_FEATURES_DEEP + PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES_DEEP * NUM_CLASSES
    );
    return z;
  }

  // src/spell-caster.js
  function SpellCaster() {
    const scaledCanvas = document.createElement("canvas");
    const scaledCtx = scaledCanvas.getContext("2d");
    document.body.appendChild(scaledCanvas);
    scaledCanvas.style.position = "fixed";
    scaledCanvas.style.top = "10px";
    scaledCanvas.style.left = "10px";
    scaledCanvas.style.border = "1px solid red";
    scaledCanvas.width = 28;
    scaledCanvas.height = 28;
    const grayscaleArray = new Array(28 * 28);
    const mapping = {
      0: "garbage",
      1: "circle",
      2: "triangle",
      3: "bolt",
      4: "wave",
      5: "caret",
      6: "hourglass"
    };
    const colorMap = {
      0: [0.4, 0.4, 0.4],
      1: [1, 0.3, 0.3],
      2: [0.3, 0.65, 1],
      3: [0.4, 1, 0.4],
      4: [1, 1, 0.3],
      5: [1, 0.65, 0.3],
      6: [1, 0.4, 1]
    };
    const lines = [];
    let isDrawing = false;
    let selectedLines = [];
    let selectedClass = -1;
    let timeSinceSelect = 0;
    function onMouseDown(evt) {
      selectedClass = -1;
      lines.length = 0;
      lines.push([evt.clientX, evt.clientY]);
      isDrawing = true;
    }
    function onMouseMove(evt) {
      if (isDrawing && lines.length > 0) {
        const latestPt = lines[lines.length - 1];
        let dx = evt.clientX - latestPt[0];
        let dy = evt.clientY - latestPt[1];
        if (dx * dx + dy * dy > 20) {
          lines.push([evt.clientX, evt.clientY]);
          classifyDrawing();
        }
      }
    }
    function onMouseUp(evt) {
      selectedClass = classifyDrawing();
      selectedLines = JSON.parse(JSON.stringify(lines));
      timeSinceSelect = 0;
      lines.length = 0;
      isDrawing = false;
    }
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    function classifyDrawing() {
      let mins = [Infinity, Infinity];
      let maxs = [-Infinity, -Infinity];
      lines.map((pt) => {
        mins[0] = Math.min(pt[0], mins[0]);
        mins[1] = Math.min(pt[1], mins[1]);
        maxs[0] = Math.max(pt[0], maxs[0]);
        maxs[1] = Math.max(pt[1], maxs[1]);
      });
      let normalizeLines = [];
      const size = Math.max(maxs[0] - mins[0], maxs[1] - mins[1], 100);
      const tracker = {};
      let topPred = 0;
      let topVal = 0;
      for (let i = 0; i < 20; i++) {
        normalizeLines = [];
        const SKX = Math.random() * 3 + 16;
        const SKY = Math.random() * 3 + 16;
        lines.map((pt) => {
          normalizeLines.push([
            (pt[0] - (maxs[0] + mins[0]) / 2) / size * SKX,
            (pt[1] - (maxs[1] + mins[1]) / 2) / size * SKY
          ]);
        });
        scaledCtx.setTransform(1, 0, 0, 1, 0, 0);
        scaledCtx.clearRect(0, 0, 28, 28);
        scaledCtx.strokeStyle = "white";
        scaledCtx.lineWidth = Math.random() * 0.5 + 1.3;
        scaledCtx.lineJoin = "round";
        scaledCtx.lineCap = "round";
        scaledCtx.setTransform(
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 2 + 14,
          (Math.random() - 0.5) * 2 + 14
        );
        renderLines(scaledCtx, normalizeLines);
        const scaledImage = scaledCtx.getImageData(0, 0, 28, 28);
        const pixelData = scaledImage.data;
        for (let i2 = 0; i2 < pixelData.length; i2 += 4) {
          grayscaleArray[i2 >> 2] = pixelData[i2] / 255;
        }
        const z2 = classify(grayscaleArray);
        const argmax = (arr) => arr.reduce((iMax, x, i2, arr2) => x > arr2[iMax] ? i2 : iMax, 0);
        const prediction = argmax(z2);
        if (tracker[prediction] === void 0) {
          tracker[prediction] = 0;
        }
        tracker[prediction] += 1;
        const v = tracker[prediction];
        if (v > topVal) {
          topVal = v;
          topPred = prediction;
        }
      }
      console.log(Object.keys(tracker).map((k) => {
        return `${mapping[parseInt(k)]}: ${tracker[k]}`;
      }));
      return topPred;
    }
    function render(ctx2) {
      if (isDrawing) {
        ctx2.strokeStyle = "white";
        ctx2.lineWidth = 20;
        renderLines(ctx2, lines);
      }
      if (selectedClass != -1) {
        const classLabel = mapping[selectedClass];
        ctx2.fillStyle = "#fff";
        ctx2.textAlign = "center";
        ctx2.font = "bold 48px arial";
        ctx2.fillText(classLabel, canvas.width / 2, 100);
        const p = Math.exp(-timeSinceSelect * 3) * 2;
        const c = colorMap[selectedClass];
        ctx2.strokeStyle = `rgba(${p * c[0] * 255}, ${p * c[1] * 255}, ${p * c[2] * 255}, ${p * 0.6})`;
        ctx2.lineWidth = 20 + (1 - Math.exp(-timeSinceSelect * 5)) * 80;
        renderLines(ctx2, selectedLines);
        ctx2.strokeStyle = `rgba(${p * c[0] * 300}, ${p * c[1] * 300}, ${p * c[2] * 300}, ${p})`;
        ctx2.lineWidth = 20;
        renderLines(ctx2, selectedLines);
      }
    }
    function update(dT) {
      timeSinceSelect += dT;
      if (selectedClass != -1 && timeSinceSelect < 5) {
        selectedLines.map((pt, i) => {
          pt[0] += Math.cos(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
          pt[1] += Math.sin(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
        });
      }
    }
    return {
      update,
      render
    };
  }
  var spell_caster_default = SpellCaster;

  // src/main.js
  function initialize() {
    add(spell_caster_default());
  }
  initialize();
})();
</script>