<html><title>Runekeeper</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  function renderLines(ctx2, lines) {
    ctx2.beginPath();
    lines.map((pt, i) => {
      if (i == 0) {
        ctx2.moveTo(pt[0], pt[1]);
      } else {
        ctx2.lineTo(pt[0], pt[1]);
      }
    });
    ctx2.stroke();
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function arrayRemove(list, valuesToEvict) {
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // ../rune-classifier/base64_encoded_model.txt
  var base64_encoded_model_default = "q6qYqKqKeKqaiZaqmYi5uoqXq5qKqrqpeXepzHeYuYx3mJh3eIh5h2d3eIeHeHhmh2aIu2uIqst4qKt5mJt5qKp4t6uJRbqZV5WZmIh3iImHmIeId4eImYmXiIeXd4iIiIm7rKusqru7qrnMjJi5qmiGulpnh6hWdoiYiKiJqpqZqLupaKucicermWe6q3m2upqJiIiIiYmIl6mZiJm6moiqmpiXq4p4map4t4lnZat4d8ibZ2e8iHjGq5mIvJuKt7uamXiJmYqXiJl2iKlrh7i6hqi6e4ipy3ipzIqHmJh3iIl5d4iJdpioWna6y3WIu3x4yMyJiamKmIeYeHeIiIdod4d3eHeId3iIZ3iWeGd2mIdniIhodoh4eHeZmoiYqZqbqZq6qqmquaq6mryaqrirqpq7m4mpqoiHmolnh3eImZmXh5eHd5iYl3iJeXeJh4h3iZl3eFZmiGhWd7lmh5h7eJi7hqmqnIm7q5nLq8uselbMqom3vIqIq5mJeYeYqXWGmkpll6pldrpqh6mrZ5jLa5eou3eoy4yYuauImLt6iXmYeId4h5iHh4d3d4mXmHiYh4iIh3d42IuIqNrNiLuJtYhaVqh4l4mLaYeWqJineamHl4l2eKuYhlyaiJqJiHeJipiIiHeHqZioiKiHiXmWmYiIiImIl5qKZ4l5h3mJeIZ4mIiYh6eXqYqZaJqJeJiJhoVnhpiIdpiHiZiKd6mYd6mIpoh2h5ialWmYeIiqqZiXiLmYeImVuFaJiGaEl4mLZ6hpmZd4WYiHuoiXmamIeYmHmYmHmHl5iHiYh4iIeGiIiYmImXmJeGh4eIaLdrt4mamLeXeKmZmHiah4iYqLeKuHioubh3mIiIiIiHeIeIZnhpindnmImJmXmJiHeGmJeYaJl5mYiJmJe4iouniIi6d3p4qJiId3iId4d4mWmWZ4iGeHmYmqmZmJipl5eXeWp3aYiYd3iImZd4h4iHl5eIWIeIh3h6eHiXqYmXh4mXmIiYmaeJmHiKmKeIZ4h5iYd5h3loVXZpiKhYiHmIl2h5maiHp4qHmZiZmIiXqJqImrmJp4irh4qIqIiIh6iXeYp5d7d5iKh6iIeYeWqXaYmJaFl5h4hrqodnuJh4h4l3aJh4iHeYiHqZioeZiHeJiHiIiJeJiHl4h2iIiYlnmXeIeZiKmHiaqKiHmWmZinmHqKp5l4Z5mIeGqJioinqWZpiqWFmXmHiKmYl2ual4mYmGWJiId2p5h7aJl5iJeHaZeHmIapmJaGl5eIl3aaeJeGpohnd5iLd4eXeXeIqKinmLqZiIuomoipiYqJl3l4iKqYiJmJeYinuXeXeXiHmHmJmHh4iIiImJh6d3dqeKaYh3mHiHaYh4d2iZaImLqniLmKd3Z3h5mYhoqIqYuYimeJeniYl4l5Z4h5eIiImZmqiZmHmpqKhod2l2aJhneHiIiZeImHiYh4p4h3h5mYmJmZmZiWl5iZh3iItZhndoeLdXeGuIuYeJmJiIiJiXq5qYd5i5aGl3l4d6mZd4l6iYmHqJiph5mItnh4eHaJl3iIh4d4mIh4mImIiIiIeIh5h4iImIl3iHl5iHiHeIiHiJmJh3iJmIqYmImXeHqZiImJmGaIiKd3eYiXqHeIeJiHhodnZ4d4dpeXmHq5qHiJi4eIeYaHl5ind5mIiIeHmHaJiIeGlolpZ6h5d4iZeIiJiIh3iYmIaZiYiXloiZiHiYiaiWdoipZ4iJZ4eHd3iJeHmZqHiJeamImKq5hpeJl4iJiZmZh4uYiImpiIiZmJiIiZjJmYiImYiKppiYyIh5inmZiJiLd3iYuYmXeZmXilaJl2aph5mJiHlah4ZoiGmneHeXd3mYhoeJiniZh4aoiJiploiZmHl4hoaZh3iKmGmHeXyqaoiId4m4qohomImqa7iZmJiZiIeYeYiId5iXh5d4h4iZmImId3iJiIiLpYmJl2qZmGmHiHjJeZmamHiqiLaZiYaGaJiJeJVXiJh4h4dYloaWiJd2hmlnmIeWaGipmGWXl5qJl4lql3aHiIeGl4iHh3apl5iHaJaJd5iYiKd3iJmnh6l4eXdqeIh1l5iHaKdYaImoiah1eHmWaKdYaHh5iZl5aJlpiWmpeXeYiImamXiJmHmZiXdomHiKh4eJp2qZiGdneHepaJmKiFipd5VniYiIiXd5p3qoeGh5iGqaeYhoiFepipeGh4mIeph5iZmJaYiYiJl4iaiYh4iJZ3l5iJh3eIl6l5dYmJmYiHeImGaXeJeHtolniIqIaYeJloWXmJSYiGhph4aZiHeYmElndViGWZh4aYeZaYiGdnhZiYeGqIiIdnmYmZeKlHeIh5qWlomHiIqohnqKmKaImKd3iGmJqWh1mJmIaXl5eXm4iXlWaIiYaZmod5iHdYiHeJd2iJenl5l3p2eXmKhXmIl5iIqLt2eIqHmohnlqd4iph4t7iXmperenhmepeKeJiHVqlXZ3iHVpVneqd2h4l1d3iWiHqZaXh4i3iIqHiIl5aYtnd2eIeKiHiYaImYmIh5dnh5l4eIameJmHd4aFl6hoiJaXeYmYeJeJeZiIh5d5iYiXh5iId3lpiamIiIiJmKBw==";

  // src/rune-model.js
  var encodedWeights = atob(base64_encoded_model_default);
  var modelParams = [];
  for (let i = 0; i < 0 + 1 * encodedWeights.length; i++) {
    const a = encodedWeights.charCodeAt(i);
    modelParams.push(((a & 15) - 8) * 2.2 / 16, ((a >> 4 & 15) - 8) * 2.2 / 16);
  }
  function linearReluLayer(data, modelParams2, numOutputs, numInputs, x0, y0, span, stride, weightOffset, biasOffset) {
    const outputs = new Array(numOutputs);
    for (let i = 0; i < numOutputs; i++) {
      let acc = 0;
      for (let j = 0; j < numInputs; j++) {
        const inputIndex = y0 + j % span + stride * (x0 + Math.floor(j / span));
        const weightIndex = weightOffset + i * numInputs + j;
        acc += modelParams2[weightIndex] * data[inputIndex];
      }
      const biasIndex = i + biasOffset + weightOffset;
      outputs[i] = Math.max(0, modelParams2[biasIndex] + acc);
    }
    return outputs;
  }
  function classify(data) {
    const BASE_PATCH = 7 * 7;
    const PATCH_FEATURES = 18;
    const PATCH_FEATURES_DEEP = 24;
    const NUM_CLASSES = 13;
    x11 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x12 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x13 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x14 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x21 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x22 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x23 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x24 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x31 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x32 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x33 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x34 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x41 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x42 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x43 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x44 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    y11 = linearReluLayer(
      x11.concat(x12, x21, x22),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    y12 = linearReluLayer(
      x13.concat(x14, x23, x24),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    y21 = linearReluLayer(
      x31.concat(x32, x41, x42),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    y22 = linearReluLayer(
      x33.concat(x34, x43, x44),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    z = linearReluLayer(
      y11.concat(y12, y21, y22),
      modelParams,
      NUM_CLASSES,
      4 * PATCH_FEATURES_DEEP,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES + 4 * PATCH_FEATURES * PATCH_FEATURES_DEEP + PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES_DEEP * NUM_CLASSES
    );
    return z;
  }

  // src/spell-caster.js
  function SpellCaster() {
    const scaledCanvas = document.createElement("canvas");
    const scaledCtx = scaledCanvas.getContext("2d");
    document.body.appendChild(scaledCanvas);
    scaledCanvas.style.position = "fixed";
    scaledCanvas.style.top = "10px";
    scaledCanvas.style.left = "10px";
    scaledCanvas.width = 28;
    scaledCanvas.height = 28;
    const grayscaleArray = new Array(28 * 28);
    const mapping = {
      0: "garbage",
      1: "fireball",
      2: "meteor",
      3: "dragon",
      4: "ice",
      5: "frost",
      6: "hail",
      7: "lightning",
      8: "tornado",
      9: "windwalk",
      10: "transfusion",
      11: "vine",
      12: "shockwave"
    };
    const lines = [];
    let isDrawing = false;
    function onMouseDown(evt) {
      lines.length = 0;
      lines.push([evt.clientX, evt.clientY]);
      isDrawing = true;
    }
    function onMouseMove(evt) {
      if (isDrawing && lines.length > 0) {
        const latestPt = lines[lines.length - 1];
        let dx = evt.clientX - latestPt[0];
        let dy = evt.clientY - latestPt[1];
        if (dx * dx + dy * dy > 20) {
          lines.push([evt.clientX, evt.clientY]);
          classifyDrawing();
        }
      }
    }
    function onMouseUp(evt) {
      classifyDrawing();
      lines.length = 0;
      isDrawing = false;
    }
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    function classifyDrawing() {
      let mins = [Infinity, Infinity];
      let maxs = [-Infinity, -Infinity];
      lines.map((pt) => {
        mins[0] = Math.min(pt[0], mins[0]);
        mins[1] = Math.min(pt[1], mins[1]);
        maxs[0] = Math.max(pt[0], maxs[0]);
        maxs[1] = Math.max(pt[1], maxs[1]);
      });
      normalizeLines = [];
      const size = Math.max(maxs[0] - mins[0], maxs[1] - mins[1]);
      lines.map((pt) => {
        normalizeLines.push([
          (pt[0] - (maxs[0] + mins[0]) / 2) / size * 20 + 14,
          (pt[1] - (maxs[1] + mins[1]) / 2) / size * 20 + 14
        ]);
      });
      scaledCtx.clearRect(0, 0, 28, 28);
      scaledCtx.strokeStyle = "white";
      scaledCtx.lineWidth = 2.5;
      renderLines(scaledCtx, normalizeLines);
      const scaledImage = scaledCtx.getImageData(0, 0, 28, 28);
      const pixelData = scaledImage.data;
      for (let i = 0; i < pixelData.length; i += 4) {
        grayscaleArray[i >> 2] = pixelData[i] / 255;
      }
      const z2 = classify(grayscaleArray);
      const argmax = (arr) => arr.reduce((iMax, x, i, arr2) => x > arr2[iMax] ? i : iMax, 0);
      console.log(mapping[argmax(z2)], z2);
    }
    function render(ctx2) {
      if (isDrawing) {
        ctx2.strokeStyle = "white";
        ctx2.lineWidth = 20;
        renderLines(ctx2, lines);
      }
    }
    function update(dT) {
    }
    return {
      update,
      render
    };
  }
  var spell_caster_default = SpellCaster;

  // src/main.js
  function initialize() {
    add(spell_caster_default());
  }
  initialize();
})();
</script>