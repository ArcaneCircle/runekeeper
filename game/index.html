<html><title>Runekeeper</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  function renderLines(ctx2, lines) {
    ctx2.beginPath();
    lines.map((pt, i) => {
      if (i == 0) {
        ctx2.moveTo(pt[0], pt[1]);
      } else {
        ctx2.lineTo(pt[0], pt[1]);
      }
    });
    ctx2.stroke();
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function arrayRemove(list, valuesToEvict) {
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // ../rune-classifier/base64_encoded_model.txt
  var base64_encoded_model_default = "eJiYiIiIeHiIiXeIiIiXmXh3iXh5iIiHh4eJiXiZmJiHiHeIiIiYh3eIeZeYeIh3iHeJiXaJiIh5iJmHiIl5h5iYmYiIiIeIiIiIl4h3h4mHmIiIh5iImYmYiIeXh3h4h3mYeXh5iYiIiJeJeJeXd3iYmXiJiJd5h4mIiIeJmHiIiJmXeHh5iJiIh4eIiXiXiHiIiIh3iImIl5iIh3mYiYiIiYiHiImId4h4l3d3d4iIiYmIeIiIh4iHiIiYiXiJl4mImIiJiYmYeHiIiYh4mZd3l5iId4iIiHeJmZeXiJh4iImZiHiImYiHiIiZmYd4eIh4l4h4eJh4h3d3eHiJh5d5d4d3iXiIiIiIeImYiXeHl5iIeYiJd4eIiHeIiXeHiHmIl3iHmJiImIiIiJl4iIeIiIiIiYiImZiYiHh3h3eImZmXh5iId6iYl3iJiXeIl4h3iZl4eHh4eId3iJl3mIiZeYiJh4iImXiYeHiZeJiIiXeIl5mJmYmYiIiIaIeHiIeXiXiHiIiHiImHmIl4iJiYh5h3eIiYmYiZh3iId5h4iXmIeId4h5iHh4d3d4iXiHiIh4iIh3d4iHiImIiIiJiIh4h5iJeYmZiJiIiXiJmYeIiYiIiHiImHiImYiIl4eHiIiImJiHiImJiYh5h3mHmXeIh4d4h4eJmJiHh4h3iIeIeHiYiHh5eXmYmIeImIeJiIh4d4h5mId5iIiYmJd5eId4iHiIiHmImIh4eYd4iZiYiHmJmXiJmIl4mId3iHd4h5h4d5l4d3eIiImIiXiIiIiIl4mImYmIiIiHeImJmJeHiHeIiImXiJiHh4eIiJd4l5mIiJiHiJmYiIiHd3eIiIiYmYiYmYh4mImIiHh3eIiId4h5iYd3iIl5eIh5eHd4eIeYeJl4iYmImJiYiHmYiIiYh4l4l4mId3iIh3d4mXmXd3mImJmJmYiIiJiXl5iHiHiHeIiIh4d4iIh4iIiHl4eIeHeId3h4mIiIiIiHiImImImImZiYiHmJiJiHiIiJmId5d3mZeIh5iJh5iHeIiIeIiImYl4mHiZiZiIiXmImImZh4l5iJh4iIh3iIh4iIeIl5iJh5iZiImJeYeIiYeIiIeHeIiIiKiGiIiHeIh4hoeImIiIiIiIiImIeIiIiIiJiIiIiJeIiIiIiHiIiIiXeIiIiIiIiYiIh4iIiIiIiIiIiYiHiIiIiIiIiIiIiIiJiIiIiHeIiIiIiHmIeIiIh4iIiImIiIiJiIiIiIiHiIiIiJiImId3mJiIh3iIh3iHiHiIiId4iIeIeIiIh4iHiJmHeIiIiIeIiIiIh4l3iYiIiIeIiHiImIiIeXiHeIiIiIh4iIeYiIh3eId4d4eYd3mHiIiHiIh4iJeYiIiIiIiIiYiHiIiHmImIiIiIeHiJiIeIiIh4eIiIiIiHiIiYiImImIiIh4iIiHiIh5iIiIiIiIiIiIiIiIiIiIh3mYiIeIiHiIiIiIiJmIiIiIiIeIiIiIiIiHiIiJiIiHiIiIiIiIiIiImIiIiIiIh4iIiIiIeIiIiIiIiIiIiIiHiIiIh4mIh4mImIiIiIiIh4h4iIl3iIiImJiHiIiIiHiJh4iIiIiImIiImIiIiYiIiIh4iYiJiIiIiImIh4iIiIiIiHiIiIiIiIh4iImIiIiYeIiIeHiIiYeHiIeIiIeIiIiIiIiIiIeZiIeYiIh4h4eHiIiJiIeIeHiHiIiIiHiIiIiIiIiIh4iYiHiIiIiIiIiYiIiIeIiHh4iIiId4iHmIiIiIiIiHh4iIiIeIl4mIiIiIiIiIiIiIiJiHiIiIiIiIiIiIiIiHiIiYeIiImIiIiIiIiJiIiHh4eIiIiIiYiIiIeIiIiIiIiIiHiIiHiIiIiIiIh4h4h4iIiHeIiIeIiIiImIiHd4mIiJiIiJiJiJd4iHiYmIiYiYiIh4iIiIeIiHiIiIiYiImIiIiIiIiIh3iHd3iIiImYeIiImIiIiIh4eIeHeYiIl4iIiIh4iHiIh4iIiIiIiIiHiIeIeYiIiIeIiIiJiIiIiIiIh4eIiIiZh3iIiIiIiIiIeIiIh4iIiIiIiIiHd4iIiIiImIiIiIiIh4iYiYiIiHiIiIiIiIiJiIiHiIiIiIiYeYiYiJiJiXiIiHiIiIh4mHd5iIiZiJiJiYiIiIiIiIiIiIiYeIeHiIiIiIiJmJiIiIh4iIiIiIiIiIiIiIiIiIiIiIh4l4iIiIiIiIiYeJiIeIeJiIiIiIiIiHiIl4eImIiJiIh4eYiHiIiIiIiIiImYiIiIiIiIiIiIiIiJiIiIiIiIeIiId4iYiIiIiJh4iHiIiHiIiImIiIiHiIiImIiIiIiIiJmHiIiIiIiIh3h5d5iIiIiIeHiIiIiIiId4eIiIiIiIiIiYiIiIiIiJiIiIeIiIiHmIiIiIl4iIiHiIiIiIiIiIeJmIiIiHiIeIh4iIiIiIiIiIiYiJiJiIiIiIiIiIiIeIiIiIiId4iIiIh3iIh3iIh4iIeIiHeIiYiIiIiIiIiIh4eIiIiIeHiIh4iXiImIiYeYmIiIiHiIh4l4h3h4iIh4iJd4iHmIeIeHiIiHiIiIiIiIiHmIh4iYiJl4iJiJh4iIiImIeIiHiIh4iIiHiIiIiJh4iIiIiIiYiId4iIiHiIh4iHiIiIiIiIh4h4h4iIiYiIiIiIiIiHiImIeIiYiIiIiIiIiIiHiJiIiIh4iIiIh4iIeIiIiIiHiIiJiIeIiImHiJiIiIiHmIiIiIiIh4iIiIiIiIh4iIh4iIiIh4iIiIiIiIiIiHh4h4iIiIiIiIiYh4eImIiIiHiIh5iIiIiIiJiIiIiYiIiIeYiHiIiIiIiIiImIiJh4iHiIeJiHiIiIeHiIiIiHiIiIeIh4iHiId3iImHeIeIh4mIiIiIiIeIiIiJiIiIiIiYiIiIiIiHiIiJeIiIeImIiJiIiIiIiImIiIeIiJiIiIiIiJh4iIiIh4iYeYiIiIiIiIiHiImIiId4iIiIiHmJiIiIiIiHiXiIiIiIiIiZeYiIiHiIiYiIiIiIiIiIiIiIiIiJiIiYiXiIh3h4iIiIiIiYd4iIiIiIiJiHiIiIiIiIeImHiImIiIiIiIiIiIh4iHiHiHeIiIiIiIiImIiImYiIiIiIiYiIiHmYeJiImYiIeIeIiJiIiYiYmIiJiIiIiYmIiIl4iImIiIiJiIiIiIiHiIiIiIiIiIiIiIiIiImIiIiImIiIiIiIiIiIh4h4iIiIiIh4iHiIiHiIiIiYiIl4iIiIh4iJh4iIiIiIiIh4iIiIeZeIh4h4iIh3eHiIiJiIiIiIh4iIiIiIiIiIiIeIiIiIiIiIiIiImIiIiIiIh4iJiIiIiIiHiIeIiIiIiIiIiIiIiXiIiIiIiIeIiIiJh4h3iIiHiYmJiIeIiIiIh2qYmYd3mZmYmKZ4l4iYmXiWmJl4iHl4apmIlpl5loaaiamZd6aKiYmniHmYeIaYiHqZqJmZVneXiIaJZ3mVd3ead5mJiZiGVXmHaHiWiYlqmod4mXiWhmiJiYtneJh3qoepd4dpmJmnhoiWd3l5mohXd5eYh5h5Z5aXaKd5qZeJh3moeohpmXeGqHiZeHd3mql6l4h4iImZiXqqmZl2eYaIlqeImJqImnl5mmiYd4ipl3l3iIiHmWmZl5aWepl4h3eYl4iWimeIiJiJeHiHh7pZeHmIZ3qWmIaJuYmIhoh3iXmJiWdoiKiaaJh4h3d4mHeWl5l6l3aJaHeJmIl4iJiXl3lmiJeXhph5h5mYmJhneHhpiJeZloeXmZZ6iXp6eKmXd4mnmWaHpomYiGiZiYeWmZZoeXmYmVeah3mJmIlplpeJmGl4mXmIdYiZl4l4qZqHmYiJmHqZZpeHiZd5h3Z4";

  // src/rune-model.js
  var encodedWeights = atob(base64_encoded_model_default);
  var modelParams = [];
  for (let i = 0; i < 0 + 1 * encodedWeights.length; i++) {
    const a = encodedWeights.charCodeAt(i);
    modelParams.push(((a & 15) - 8) * 2.2 / 16, ((a >> 4 & 15) - 8) * 2.2 / 16);
  }
  function linearReluLayer(data, modelParams2, numOutputs, numInputs, x0, y0, span, stride, weightOffset, biasOffset) {
    const outputs = new Array(numOutputs);
    for (let i = 0; i < numOutputs; i++) {
      let acc = 0;
      for (let j = 0; j < numInputs; j++) {
        const inputIndex = y0 + j % span + stride * (x0 + Math.floor(j / span));
        const weightIndex = weightOffset + i * numInputs + j;
        acc += modelParams2[weightIndex] * data[inputIndex];
      }
      const biasIndex = i + biasOffset + weightOffset;
      outputs[i] = Math.max(0, modelParams2[biasIndex] + acc);
    }
    return outputs;
  }
  function layerNorm(t) {
    const mean = t.reduce((acc, val) => acc + val, 0) / t.length;
    const variance = t.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / t.length;
    return t.map((val) => (val - mean) / Math.sqrt(variance + 1e-3));
  }
  function classify(data) {
    const BASE_PATCH = 7 * 7;
    const PATCH_FEATURES = 34;
    const PATCH_FEATURES_DEEP = 25;
    const NUM_CLASSES = 7;
    x11 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x12 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x13 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x14 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x21 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x22 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x23 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x24 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x31 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x32 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x33 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x34 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x41 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x42 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x43 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x44 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    y11 = layerNorm(linearReluLayer(
      x11.concat(x12, x21, x22),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y12 = layerNorm(linearReluLayer(
      x13.concat(x14, x23, x24),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y21 = layerNorm(linearReluLayer(
      x31.concat(x32, x41, x42),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y22 = layerNorm(linearReluLayer(
      x33.concat(x34, x43, x44),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    z = linearReluLayer(
      y11.concat(y12, y21, y22),
      modelParams,
      NUM_CLASSES,
      4 * PATCH_FEATURES_DEEP,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES + 4 * PATCH_FEATURES * PATCH_FEATURES_DEEP + PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES_DEEP * NUM_CLASSES
    );
    return z;
  }

  // src/spell-caster.js
  function SpellCaster() {
    const scaledCanvas = document.createElement("canvas");
    const scaledCtx = scaledCanvas.getContext("2d");
    document.body.appendChild(scaledCanvas);
    scaledCanvas.style.position = "fixed";
    scaledCanvas.style.top = "10px";
    scaledCanvas.style.left = "10px";
    scaledCanvas.style.border = "1px solid red";
    scaledCanvas.width = 28;
    scaledCanvas.height = 28;
    const grayscaleArray = new Array(28 * 28);
    const mapping = {
      0: "garbage",
      1: "circle",
      2: "triangle",
      3: "bolt",
      4: "wave",
      5: "caret",
      6: "hourglass"
    };
    const colorMap = {
      0: [0.4, 0.4, 0.4],
      1: [1, 0.65, 0.3],
      2: [0.3, 0.65, 1],
      3: [1, 1, 0.1],
      4: [0.3, 1, 0.65],
      5: [1, 0.1, 1],
      6: [1, 1, 1]
    };
    const lines = [];
    let isDrawing = false;
    let selectedLines = [];
    let selectedClass = -1;
    let timeSinceSelect = 0;
    function onMouseDown(evt) {
      selectedClass = -1;
      lines.length = 0;
      lines.push([evt.clientX, evt.clientY]);
      isDrawing = true;
    }
    function onMouseMove(evt) {
      if (isDrawing && lines.length > 0) {
        const latestPt = lines[lines.length - 1];
        let dx = evt.clientX - latestPt[0];
        let dy = evt.clientY - latestPt[1];
        if (dx * dx + dy * dy > 20) {
          lines.push([evt.clientX, evt.clientY]);
          classifyDrawing();
        }
      }
    }
    function onMouseUp(evt) {
      selectedClass = classifyDrawing();
      selectedLines = JSON.parse(JSON.stringify(lines));
      timeSinceSelect = 0;
      lines.length = 0;
      isDrawing = false;
    }
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    function classifyDrawing() {
      let mins = [Infinity, Infinity];
      let maxs = [-Infinity, -Infinity];
      lines.map((pt) => {
        mins[0] = Math.min(pt[0], mins[0]);
        mins[1] = Math.min(pt[1], mins[1]);
        maxs[0] = Math.max(pt[0], maxs[0]);
        maxs[1] = Math.max(pt[1], maxs[1]);
      });
      let normalizeLines = [];
      const size = Math.max(maxs[0] - mins[0], maxs[1] - mins[1], 100);
      const tracker = {};
      let topPred = 0;
      let topVal = 0;
      for (let i = 0; i < 20; i++) {
        normalizeLines = [];
        const SKX = Math.random() * 3 + 16;
        const SKY = Math.random() * 3 + 16;
        lines.map((pt) => {
          normalizeLines.push([
            (pt[0] - (maxs[0] + mins[0]) / 2) / size * SKX,
            (pt[1] - (maxs[1] + mins[1]) / 2) / size * SKY
          ]);
        });
        scaledCtx.setTransform(1, 0, 0, 1, 0, 0);
        scaledCtx.clearRect(0, 0, 28, 28);
        scaledCtx.strokeStyle = "white";
        scaledCtx.lineWidth = Math.random() * 0.5 + 1.3;
        scaledCtx.lineJoin = "round";
        scaledCtx.lineCap = "round";
        scaledCtx.setTransform(
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 2 + 14,
          (Math.random() - 0.5) * 2 + 14
        );
        renderLines(scaledCtx, normalizeLines);
        const scaledImage = scaledCtx.getImageData(0, 0, 28, 28);
        const pixelData = scaledImage.data;
        for (let i2 = 0; i2 < pixelData.length; i2 += 4) {
          grayscaleArray[i2 >> 2] = pixelData[i2] / 255;
        }
        const z2 = classify(grayscaleArray);
        const argmax = (arr) => arr.reduce((iMax, x, i2, arr2) => x > arr2[iMax] ? i2 : iMax, 0);
        const prediction = argmax(z2);
        if (tracker[prediction] === void 0) {
          tracker[prediction] = 0;
        }
        tracker[prediction] += prediction == 0 ? 1 : 2;
        const v = tracker[prediction];
        if (v > topVal) {
          topVal = v;
          topPred = prediction;
        }
      }
      console.log(Object.keys(tracker).map((k) => {
        return `${mapping[parseInt(k)]}: ${tracker[k]}`;
      }));
      return topPred;
    }
    function render(ctx2) {
      if (isDrawing) {
        ctx2.strokeStyle = "white";
        ctx2.lineWidth = 20;
        renderLines(ctx2, lines);
      }
      if (selectedClass != -1) {
        const classLabel = mapping[selectedClass];
        ctx2.fillStyle = "#fff";
        ctx2.textAlign = "center";
        ctx2.font = "bold 48px arial";
        ctx2.fillText(classLabel, canvas.width / 2, 100);
        const p = Math.exp(-timeSinceSelect * 3) * 2;
        const c = colorMap[selectedClass];
        ctx2.strokeStyle = `rgba(${p * c[0] * 255}, ${p * c[1] * 255}, ${p * c[2] * 255}, ${p * 0.6})`;
        ctx2.lineWidth = 20 + (1 - Math.exp(-timeSinceSelect * 5)) * 80;
        renderLines(ctx2, selectedLines);
        ctx2.strokeStyle = `rgba(${p * c[0] * 300}, ${p * c[1] * 300}, ${p * c[2] * 300}, ${p})`;
        ctx2.lineWidth = 20;
        renderLines(ctx2, selectedLines);
      }
    }
    function update(dT) {
      timeSinceSelect += dT;
      if (selectedClass != -1 && timeSinceSelect < 5) {
        selectedLines.map((pt, i) => {
          pt[0] += Math.cos(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
          pt[1] += Math.sin(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
        });
      }
    }
    return {
      update,
      render
    };
  }
  var spell_caster_default = SpellCaster;

  // src/main.js
  function initialize() {
    add(spell_caster_default());
  }
  initialize();
})();
</script>