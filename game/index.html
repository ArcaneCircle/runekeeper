<html><title>Runekeeper</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  function renderLines(ctx2, lines) {
    ctx2.beginPath();
    lines.map((pt, i) => {
      if (i == 0) {
        ctx2.moveTo(pt[0], pt[1]);
      } else {
        ctx2.lineTo(pt[0], pt[1]);
      }
    });
    ctx2.stroke();
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function arrayRemove(list, valuesToEvict) {
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // ../rune-classifier/base64_encoded_model.txt
  var base64_encoded_model_default = "iZiYiJiZmYeZqnmIqaqGqZp5iJmaiJiZeIeqzHeZuZyImZmJiYiZmGd3iYd2h4lmZ4iaqnmZqrqJqbt6mKurhrmqi5iqmYeoqoqZmIh3h4mXmIeIh4eImYmHh4eXd4h4h3i7m3moq5mIqqmqiampiXioqml4mKhnhpmId5eJiHiZmJmYeJuKiMiqiHfMm3jXu4qZeIh3iIiIl5iIh3mYiYiIiYeHmXmIiIl3t4l4dqqIibiaeHiriHjGq4l3vIp4xrx5h4iJiZmYeHiIiYh4mah3l6mZeIiZmXiYqpiXmJh4iImJd4iJiJiYeoe6u4eZu4uJycyJeYiJh3d3eHiJh5d5d4d3iHiIeIiZeImXeIiYl4eIeYd4h3d3iHd4eHd3d4h5h3eXu6qZyJqpmbyJmcirmZi7m3inu5l3q5p4h3eImYmXh4d3d5iIl3iJeXeIh4h3eZmHeHhneId3eJmImIipioh5mamJqZqaiZqriamaeXaqmIiYqnmImYiHaYeHmHaGiWhmh4h2d6p5iKmrd6m7eqipqoiou3qZqImImKl5iXmYeId4h5iHh4d3d4mXmHiYh4iIh3d43JyJx7yJd7qad5eKiIeYmZl5h5ioZ5ipapeou3eHumx2l7x2drpsZ4e7d4mqeYiqq8ioiMiIyXnYerqIiIiImJmImHmZp4eYmGeIipiHh6eXqKiIiIqJeJiHhneId5mHl5Z5mZqKh5iZeYmImIeEhohol4WYdWaamml4iJmYp4mZmIqIiHiHiIiKl6iKyLeIeIx5mXmXmJiYeJmImIiImJhpeGeZh6eIeneXeIh4mYiZh3iJeYeJl4l4eommd4aJuWeIipd2SpiJmpmIiYuoiIpnh6eoiHiJiIdZh5eHd4iYlpiIlpeGlqh4iYmJlmiZmXp5iYiImYq4iJh5mHmImaeHmneGVlmHmHOGh4eIiaeomIiKeomImHmnmHeYioh5d5maeoh4iIuYeYqYeZmYiIiKiXiIaHd4iImIl4mYeIiHmKh5iImYiImZiHhniJeHlpmYl5eGmGiHeJiHh4p6emipiYiXipt3loiph4l4iZd4mYmHiJiIiIeZp7iKiYiImIqIeqdniYiIqYeHiZh5h5eGeHiYdnh4hYiKiHm4iIiIich5eYh4mZiHiXiJeYinqJh4imqIh5qaaFepmZh3i7d3lmqHeIiXp4d7mJiouHiYe4mHeoeXeId5iJeHiId5iYmHmImZl4mKiHeHiImIh4iJiKqJmIeYeImJiraImYmXmIeKp3iKh4eHl3eHiJeIeIeXh3iImIaHmKeId4iYiHiYiJh4h3l4mZmIiZeIeKeYuLd3eXuJeHiIl3l4iJiImJeJiIh5d5iZeImJmJeXd4lnmZeXmIeXmJeJiHeIeImXmJmoqIl4e3mJeZiZaGiIh4eXeKiIeaeomXiJipmJiIh3eIeYhoiJtpeYiZh4iImHiHqJe4qHyYiaiZrJh4eIqGiJmJh4aMiYd3l2mYiXiJdnhomoeIiZmJZad4eIp2iIipiGapl6eHmHl4eIiLh5iHh4qHeImImYp4i4yGh4m3qIaIeIeIh5h4iImIh4iHl5iHiHiIiHiIh4h3iJl4mIh4iXh3iYiImIh4eml5eIaIiHl4iHiImZmJh3ioh4iZaVhoh4mIeYh2eJiWhnmJiWh4mpl4eIh4eYiJiImIiImch5iYqod4qHhWWHaKmFiJZ2qImJmXmXipeIiZeImKhomImIiHeHiHh4iZmIh4eJeIeJqYh4eYh3iaqKioiZmXiIi8d4eWp4mYh4uIiKeXmomKl5eWmJl6iYdnmImYdnmaWYiIiYmYmJmId6eXl6l5l4mZeIiqeHmId4eJh3mIaJeZmYiXiIeImYaop6iamHiIl5iqmIiaiImIeYicqpp5mYmIiIiZmKmYiZiJmZuJmYiYmZuYeYinmJiYmIiKmImGiXiZmZiHmYiImYmYh2l3lWaoeYmHl4aaeJSGaJaIeoiamHiIqqiJd4iIlpmImImKiph5eXeIiWiGinuYuIial6qIuYa3iYeamYqbhlm5iYp3d6iZiZh4iJiJiZiIeZqIiImIiIl3hYd5qriYapmYmLmImnmYa5mKimmJqah5l5Z4aIiYWHeJSZmJiHeXZpZ3mIhYhnWIhoh4lZiZeIs2eHaKSKaGd5eoWHimiKaZmJl7l3mYdol6mXeKiHmXioeoaFd1p2h3aXmYeJdleomYdpmXWaaJhpd5V5iJeImImXiYiKeYh5qYmYiIiXh2mZh3iXeImqmWWaiIh6iHeoh5a5mIeEqZmIeJaZp4h4d4qHl5poV4iHh2iGqId3inqouHmHh3mpeJqXeZh5mnqKiHmZqXqYlYiIeYiHeXmFiHiVl6mImHiGeWd5iYeIV4mJaIdpiHqGmYVYiZmZiIl4eFmJlolniYqHhVmYiImaiJiJqHmJaGmIiXmHiIeYiZmaiIeZhnmaiZiWh4SZmKdnp2mJd5mop4l2iYiJh5mYaIiZeGinepiYiYmpmIeJd4eZd3h5l5iad4iYiImIiWhYh4d4mJqrmGeZl4iaaHh4l4aqp5qGpYqIqph4eqaKiHmHiGZYlpeJqKh4V3eplph3WHmXZYWomYiHiWh2ekeJeKiHiYmJiqmpeHd4d5mWiHeWiIWYaIhliWeJmGiJaHmIhmd4uYeKmHaZqYh4qXWJaZmJl5eXaXiLiHeZmoc=";

  // src/rune-model.js
  var encodedWeights = atob(base64_encoded_model_default);
  var modelParams = [];
  for (let i = 0; i < 0 + 1 * encodedWeights.length; i++) {
    const a = encodedWeights.charCodeAt(i);
    modelParams.push(((a & 15) - 8) * 2.2 / 16, ((a >> 4 & 15) - 8) * 2.2 / 16);
  }
  function linearReluLayer(data, modelParams2, numOutputs, numInputs, x0, y0, span, stride, weightOffset, biasOffset) {
    const outputs = new Array(numOutputs);
    for (let i = 0; i < numOutputs; i++) {
      let acc = 0;
      for (let j = 0; j < numInputs; j++) {
        const inputIndex = y0 + j % span + stride * (x0 + Math.floor(j / span));
        const weightIndex = weightOffset + i * numInputs + j;
        acc += modelParams2[weightIndex] * data[inputIndex];
      }
      const biasIndex = i + biasOffset + weightOffset;
      outputs[i] = Math.max(0, modelParams2[biasIndex] + acc);
    }
    return outputs;
  }
  function classify(data) {
    const BASE_PATCH = 7 * 7;
    const PATCH_FEATURES = 20;
    const PATCH_FEATURES_DEEP = 23;
    const NUM_CLASSES = 13;
    x11 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x12 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x13 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x14 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x21 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x22 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x23 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x24 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x31 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x32 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x33 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x34 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x41 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x42 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x43 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    x44 = linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES);
    y11 = linearReluLayer(
      x11.concat(x12, x21, x22),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    y12 = linearReluLayer(
      x13.concat(x14, x23, x24),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    y21 = linearReluLayer(
      x31.concat(x32, x41, x42),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    y22 = linearReluLayer(
      x33.concat(x34, x43, x44),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    );
    z = linearReluLayer(
      y11.concat(y12, y21, y22),
      modelParams,
      NUM_CLASSES,
      4 * PATCH_FEATURES_DEEP,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES + 4 * PATCH_FEATURES * PATCH_FEATURES_DEEP + PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES_DEEP * NUM_CLASSES
    );
    return z;
  }

  // src/spell-caster.js
  function SpellCaster() {
    const scaledCanvas = document.createElement("canvas");
    const scaledCtx = scaledCanvas.getContext("2d");
    document.body.appendChild(scaledCanvas);
    scaledCanvas.style.position = "fixed";
    scaledCanvas.style.top = "10px";
    scaledCanvas.style.left = "10px";
    scaledCanvas.width = 28;
    scaledCanvas.height = 28;
    const grayscaleArray = new Array(28 * 28);
    const mapping = {
      0: "garbage",
      1: "fireball",
      2: "meteor",
      3: "dragon",
      4: "ice",
      5: "frost",
      6: "hail",
      7: "lightning",
      8: "tornado",
      9: "windwalk",
      10: "transfusion",
      11: "vine",
      12: "shockwave"
    };
    const lines = [];
    let isDrawing = false;
    function onMouseDown(evt) {
      lines.length = 0;
      lines.push([evt.clientX, evt.clientY]);
      isDrawing = true;
    }
    function onMouseMove(evt) {
      if (isDrawing && lines.length > 0) {
        const latestPt = lines[lines.length - 1];
        let dx = evt.clientX - latestPt[0];
        let dy = evt.clientY - latestPt[1];
        if (dx * dx + dy * dy > 20) {
          lines.push([evt.clientX, evt.clientY]);
          classifyDrawing();
        }
      }
    }
    function onMouseUp(evt) {
      classifyDrawing();
      lines.length = 0;
      isDrawing = false;
    }
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    function classifyDrawing() {
      let mins = [Infinity, Infinity];
      let maxs = [-Infinity, -Infinity];
      lines.map((pt) => {
        mins[0] = Math.min(pt[0], mins[0]);
        mins[1] = Math.min(pt[1], mins[1]);
        maxs[0] = Math.max(pt[0], maxs[0]);
        maxs[1] = Math.max(pt[1], maxs[1]);
      });
      normalizeLines = [];
      const size = Math.max(maxs[0] - mins[0], maxs[1] - mins[1], 80);
      lines.map((pt) => {
        normalizeLines.push([
          (pt[0] - (maxs[0] + mins[0]) / 2) / size * 21 + 14,
          (pt[1] - (maxs[1] + mins[1]) / 2) / size * 21 + 14
        ]);
      });
      const tracker = {};
      for (let i = 0; i < 20; i++) {
        scaledCtx.clearRect(0, 0, 28, 28);
        scaledCtx.strokeStyle = "white";
        scaledCtx.lineWidth = 2.4;
        scaledCtx.setTransform(
          1 + (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          1 + (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        );
        renderLines(scaledCtx, normalizeLines);
        const scaledImage = scaledCtx.getImageData(0, 0, 28, 28);
        const pixelData = scaledImage.data;
        for (let i2 = 0; i2 < pixelData.length; i2 += 4) {
          grayscaleArray[i2 >> 2] = pixelData[i2] / 255;
        }
        const z2 = classify(grayscaleArray);
        const argmax = (arr) => arr.reduce((iMax, x, i2, arr2) => x > arr2[iMax] ? i2 : iMax, 0);
        const prediction = argmax(z2);
        if (tracker[prediction] === void 0) {
          tracker[prediction] = 0;
        }
        tracker[prediction] += 1;
      }
      console.log(tracker);
    }
    function render(ctx2) {
      if (isDrawing) {
        ctx2.strokeStyle = "white";
        ctx2.lineWidth = 20;
        renderLines(ctx2, lines);
      }
    }
    function update(dT) {
    }
    return {
      update,
      render
    };
  }
  var spell_caster_default = SpellCaster;

  // src/main.js
  function initialize() {
    add(spell_caster_default());
  }
  initialize();
})();
</script>