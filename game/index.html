<html><title>Runekeeper</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/bus.js
  var HANDLES = {};
  function on(e, handler) {
    (HANDLES[e] || (HANDLES[e] = [])).push(handler);
  }
  function off(e, handler) {
    HANDLES[e] = (HANDLES[e] || []).filter((x) => x != handler);
  }
  function emit(e, data) {
    (HANDLES[e] || []).map((handler) => handler(data));
  }

  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  function renderLines(ctx2, lines, close = false) {
    ctx2.beginPath();
    lines.map((pt, i) => {
      if (i == 0) {
        ctx2.moveTo(pt[0], pt[1]);
      } else {
        ctx2.lineTo(pt[0], pt[1]);
      }
    });
    if (close) {
      ctx2.closePath();
    }
    ctx2.stroke();
  }
  function renderAndFill(ctx2, lines) {
    renderLines(ctx2, lines, true);
    ctx2.fill();
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // src/color.js
  var TAN = "#f2e5a5";
  var LIGHT_BROWN = "#dbad81";
  var PURPLE = "#683492";
  var BLACK = "#000";
  var DARK_GRAY = "#474747";
  var GRAY = "#777";
  var MID_GRAY = "#a4a4a4";
  var LIGHT_GRAY = "#cbcbcb";
  var WHITE = "#fff";

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    const zoom = Math.min(
      canvas.width / 800,
      canvas.height / 1100
    );
    ctx.setTransform(zoom, 0, 0, zoom, canvas.width / 2 - 190 * zoom, canvas.height * 0.3 - 80 * 6 * 0.5 * zoom);
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    resort();
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function resort() {
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
  }
  function arrayRemove(list, valuesToEvict) {
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // src/events.js
  var SIGIL_DRAWN = 0;
  var RUNESTONE_MOVE = 1;
  var POWERUP_ACQUIRED = 2;
  var RUNESTONE_LAND = 3;
  var TURN_END = 4;
  var ABILITY_USE = 5;
  var ENEMY_DAMAGE = 6;

  // src/pulse-sfx.js
  function PulseSFX(cx, cy, scale, rgb) {
    let t = 0;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
        const p = t / 0.5;
        const r = scale * (1 - Math.exp(-p * 4));
        const alpha = 1 - p;
        ctx2.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
        ctx2.lineWidth = 12 * (1 - p);
        ctx2.beginPath();
        ctx2.ellipse(0, 0, r, r * 0.8, 0, 0, Math.PI * 2);
        ctx2.stroke();
      });
    }
    function update(dT) {
      t += dT;
      return t > 0.5;
    }
    return {
      render,
      update,
      order: 15
    };
  }
  var pulse_sfx_default = PulseSFX;

  // src/ability.js
  var POWER_COLORS = [
    [230, 30, 30],
    [48, 128, 230],
    [106, 250, 106]
  ];
  function Ability(cx, cy, powerType) {
    let anim = Math.random() * 5;
    let t = 0;
    let renderOrder = 50;
    if (powerType == 1) {
      renderOrder = 10;
    }
    add(pulse_sfx_default(cx, cy, 55, POWER_COLORS[powerType]));
    emit(ABILITY_USE, [cx, cy, powerType]);
    function update(dT) {
      anim += dT;
      t += dT * 1;
      if (t > 1) {
        return true;
      }
    }
    function render(ctx2) {
      if (powerType == 0) {
        retainTransform(() => {
          ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
          for (let i = 0; i < 12; i++) {
            const p = (i * 30 + anim * 100) % 50 / 50;
            const q = 0.15 + p * 0.85;
            const w = 1 - p * p * p * p * p;
            ctx2.fillStyle = `rgba(${255 * w}, ${(50 + p * 200) * w}, ${30 * w}, ${(1 - p) * (1 - t * t * t)})`;
            ctx2.beginPath();
            ctx2.ellipse(
              (i * 83 % 130 - 65) * 0.5,
              -p * 56 + (i * 11 % 23 - 5) * 2,
              26 * (1 - p) * q,
              26 * (1 - p) / q * p,
              0,
              0,
              Math.PI * 2
            );
            ctx2.fill();
          }
        });
      } else if (powerType == 1) {
        retainTransform(() => {
          const p = 1 - t * t * t;
          ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
          ctx2.fillStyle = "#29e";
          ctx2.fillRect(-38 * p, -38 * p, 76 * p, 76 * p);
          ctx2.strokeStyle = "#eef";
          ctx2.lineWidth = 5 * p;
          ctx2.beginPath();
          ctx2.moveTo(-25, 5);
          ctx2.lineTo(-20, -5);
          ctx2.lineTo(-15, 5);
          ctx2.moveTo(-5, 25);
          ctx2.lineTo(0, 15);
          ctx2.lineTo(5, 25);
          ctx2.moveTo(-5, -15);
          ctx2.lineTo(0, -25);
          ctx2.lineTo(5, -15);
          ctx2.moveTo(25, 5);
          ctx2.lineTo(20, -5);
          ctx2.lineTo(15, 5);
          ctx2.stroke();
        });
      } else if (powerType == 2) {
        retainTransform(() => {
          ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
          ctx2.strokeStyle = "#131";
          ctx2.lineWidth = 11 * (1 - t);
          ctx2.beginPath();
          ctx2.moveTo(-18 * Math.cos(Math.round(anim * 13) * 123), -55);
          ctx2.lineTo(18 * Math.cos(Math.round(anim * 15) * 103), -40);
          ctx2.lineTo(-11 * Math.cos(Math.round(anim * 17) * 93), -20);
          ctx2.lineTo(11 * Math.cos(Math.round(anim * 13) * 133), -15);
          ctx2.lineTo(6 * Math.cos(Math.round(anim * 11) * 97), 10);
          ctx2.stroke();
          ctx2.strokeStyle = "#1f1";
          ctx2.lineWidth = 10 * (1 - t);
          ctx2.stroke();
        });
      }
    }
    return {
      update,
      render,
      order: renderOrder
    };
  }
  var ability_default = Ability;

  // src/damage-particle.js
  function DamageParticle(cx, cy, dmg, color) {
    let anim = 0;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.3) * 80 - (1 - Math.exp(-anim * 5)) * 70);
        const alpha = 1 - anim / 2;
        ctx2.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha})`;
        ctx2.textAlign = "center";
        ctx2.font = `bold 40px arial`;
        ctx2.fillText(`-${dmg}`, 0, 0);
      });
    }
    function update(dT) {
      anim += dT;
      if (anim > 2) {
        return true;
      }
    }
    return {
      update,
      render,
      order: 100
    };
  }
  var damage_particle_default = DamageParticle;

  // src/enemy.js
  function Enemy(cx, cy) {
    let anim = Math.random() * 7;
    let targetX = cx;
    let targetY = cy;
    let originX = cx;
    let originY = cy;
    const MOVE_DURATION = 0.35;
    let self = {};
    const IDLE = 0;
    const MOVING = 1;
    const ATTACK = 2;
    let state = IDLE;
    let timeInState = 0;
    let dead = false;
    let hp = 2;
    let maxHp = hp;
    let motion = 0;
    let motionMax = 2;
    let onFire = 0;
    add(pulse_sfx_default(cx, cy, 55, [0, 0, 0]));
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
        ctx2.fillStyle = "rgba(0,0,0,0.1)";
        ctx2.beginPath();
        ctx2.ellipse(0, 0, 26, 19, 0, 0, 2 * Math.PI);
        ctx2.fill();
        if (state == MOVING) {
          const p = timeInState / MOVE_DURATION;
          ctx2.translate(0, -120 * p * (1 - p));
        }
        ctx2.lineWidth = 10;
        ctx2.fillStyle = GRAY;
        ctx2.strokeStyle = GRAY;
        const squish = Math.cos(anim * 10);
        const squish2 = Math.cos(anim * 10 + 1);
        ctx2.fillRect(-10 + squish, 0, 20 - 2 * squish, -34 - 2 * squish);
        ctx2.strokeRect(-10 + squish, 0, 20 - 2 * squish, -34 - 2 * squish);
        retainTransform(() => {
          ctx2.translate(0, -39 - squish * 3);
          ctx2.fillStyle = DARK_GRAY;
          ctx2.strokeStyle = DARK_GRAY;
          ctx2.fillRect(-6, 0, 12, -16);
          ctx2.strokeRect(-6, 0, 12, -16);
          ctx2.strokeStyle = "#c11";
          ctx2.beginPath();
          ctx2.moveTo(0, -62 + 41);
          ctx2.lineTo(1, -70 + 41);
          ctx2.lineTo(6, -74 + 41);
          ctx2.lineTo(10, -70 + 41);
          ctx2.stroke();
          ctx2.strokeStyle = LIGHT_GRAY;
          ctx2.beginPath();
          ctx2.moveTo(-3, -49 + 41);
          ctx2.lineTo(-3.01, -49 + 41);
          ctx2.stroke();
        });
        retainTransform(() => {
          ctx2.translate(-20, -18 + squish2 * 1);
          ctx2.rotate(Math.cos(anim * 10 - 0.2) * 0.04);
          if (state == ATTACK) {
            ctx2.translate(-Math.exp(-Math.pow((timeInState - 0.25) * 1.5, 2) * 25) * 20, 0);
            ctx2.rotate(-Math.exp(-Math.pow((timeInState - 0.3) * 1.5, 2) * 30) * 1.2);
          }
          ctx2.strokeStyle = "#eee";
          ctx2.beginPath();
          ctx2.moveTo(0, 0);
          ctx2.lineTo(-6, -45 + 13);
          ctx2.stroke();
          ctx2.strokeStyle = "#841";
          ctx2.beginPath();
          ctx2.moveTo(-5, 0);
          ctx2.lineTo(5, -3);
          ctx2.moveTo(0, 0);
          ctx2.lineTo(2, 4);
          ctx2.stroke();
        });
        for (let i = 0; i < maxHp; i++) {
          retainTransform(() => {
            ctx2.translate(-22 * (maxHp - 1) / 2 + 22 * i, 0);
            ctx2.beginPath();
            ctx2.strokeStyle = "#222";
            ctx2.lineWidth = 10;
            ctx2.moveTo(-5, 10);
            ctx2.lineTo(0, 15);
            ctx2.lineTo(5, 10);
            ctx2.stroke();
            if (i < hp) {
              ctx2.strokeStyle = "#f22";
              ctx2.lineWidth = 6;
              ctx2.stroke();
            }
          });
        }
        for (let i = 0; i < motionMax; i++) {
          retainTransform(() => {
            ctx2.translate(-22 * (motionMax - 1) / 2 + 22 * i, 0);
            ctx2.beginPath();
            ctx2.strokeStyle = "#222";
            ctx2.lineWidth = 10;
            ctx2.moveTo(-4, 27);
            ctx2.lineTo(4, 27);
            ctx2.stroke();
            if (i < motion || i <= motion && Math.cos(anim * 15) > 0) {
              ctx2.strokeStyle = "#3af";
              ctx2.lineWidth = 6;
              ctx2.stroke();
            }
          });
        }
        if (onFire > 0) {
          for (let i = 0; i < 9; i++) {
            const p = (i * 30 + anim * 100) % 50 / 50;
            const q = 0.15 + p * 0.85;
            const w = 1 - p * p * p * p * p;
            ctx2.fillStyle = `rgba(${255 * w}, ${(50 + p * 200) * w}, ${30 * w}, ${1 - p})`;
            ctx2.beginPath();
            ctx2.ellipse(
              (i * 83 % 130 - 65) * 0.34,
              -p * 56 + (i * 11 % 23 - 5) * 1.3,
              26 * (1 - p) * q,
              26 * (1 - p) / q * p,
              0,
              0,
              Math.PI * 2
            );
            ctx2.fill();
          }
        }
      });
    }
    function update(dT) {
      anim += dT;
      timeInState += dT;
      if (state == MOVING) {
        const p = timeInState / MOVE_DURATION;
        cx = originX * (1 - p) + targetX * p;
        cy = originY * (1 - p) + targetY * p;
        if (timeInState > MOVE_DURATION) {
          cx = targetX;
          cy = targetY;
          timeInState = 0;
          state = IDLE;
          self.order = 30 + cy * 0.02;
          resort();
        }
      }
      if (state == ATTACK && timeInState > 0.5) {
        state = IDLE;
        timeInState = 0;
      }
      if (dead) {
        off(RUNESTONE_MOVE, onRunestoneMove);
        off(TURN_END, onTurnEnd);
        off(ABILITY_USE, onAbilityUse);
        return true;
      }
    }
    function issueMove(nx, ny) {
      originX = cx;
      originY = cy;
      targetX = nx;
      targetY = ny;
      state = MOVING;
      timeInState = 0;
    }
    function onRunestoneMove() {
      motion += 1;
    }
    function onTurnEnd() {
      if (cx > 0) {
        if (motion >= motionMax) {
          motion = 0;
          issueMove(cx - 1, cy);
        }
      } else {
        state = ATTACK;
        timeInState = 0;
        emit(ENEMY_DAMAGE, 1);
        add(damage_particle_default(-1.1, cy + 0.5, 1, [255, 0, 0]));
      }
      if (onFire > 0) {
        onFire -= 1;
        takeDamage(1);
      }
    }
    function takeDamage(dmg) {
      hp -= dmg;
      add(pulse_sfx_default(cx, cy, 95, [0, 0, 0]));
      add(damage_particle_default(cx, cy, dmg, [255, 0, 0]));
      if (hp <= 0) {
        dead = true;
      }
    }
    function onAbilityUse([tx, ty, powerType]) {
      if (tx == cx && ty == cy) {
        if (powerType == 0) {
          onFire = 3;
        }
        if (powerType == 1) {
          motion = -1;
          takeDamage(1);
        }
        if (powerType == 2) {
          takeDamage(2);
        }
      }
    }
    on(RUNESTONE_MOVE, onRunestoneMove);
    on(TURN_END, onTurnEnd);
    on(ABILITY_USE, onAbilityUse);
    self = {
      update,
      render,
      tags: ["enemy", "obstacle"],
      order: 30,
      getX: () => cx,
      getY: () => cy
    };
    self.order = 30 + cy * 0.02;
    resort();
    return self;
  }
  var enemy_default = Enemy;

  // src/sensor.js
  function findObstacles() {
    return getObjectsByTag("obstacle");
  }
  function spotOccupied(x, y) {
    const obstacles = findObstacles();
    for (let i = 0; i < obstacles.length; i++) {
      const obs = obstacles[i];
      if (obs.getX() == x && obs.getY() == y) {
        return true;
      }
    }
    return false;
  }

  // src/enemy-spawner.js
  function EnemySpawner() {
    function render(ctx2) {
    }
    function update(dT) {
    }
    function spawnOne() {
      const enemies = getObjectsByTag("enemy");
      if (enemies.length < 3) {
        for (let i = 0; i < 30; i++) {
          const offerY = Math.floor(Math.random() * 6);
          if (!spotOccupied(5, offerY)) {
            add(enemy_default(5, offerY));
            break;
          }
        }
      }
    }
    function onTurnEnd() {
      spawnOne();
    }
    on(TURN_END, onTurnEnd);
    spawnOne();
    return {
      update,
      render
    };
  }
  var enemy_spawner_default = EnemySpawner;

  // src/game-arena.js
  function GameArena() {
    function render(ctx2) {
      retainTransform(() => {
        ctx2.setTransform(1, 0, 0, 1, 0, 0);
        ctx2.fillStyle = LIGHT_BROWN;
        ctx2.fillRect(0, 0, canvas.width, canvas.height);
      });
      ctx2.strokeStyle = TAN;
      ctx2.lineWidth = 4;
      ctx2.beginPath();
      const SIZE = 80;
      for (let x = 0; x <= 6; x++) {
        ctx2.moveTo(x * SIZE, 0);
        ctx2.lineTo(x * SIZE, 6 * SIZE);
        ctx2.moveTo(0, x * SIZE);
        ctx2.lineTo(6 * SIZE, x * SIZE);
      }
      ctx2.stroke();
    }
    function update(dT) {
    }
    return {
      update,
      render,
      order: -20
    };
  }
  var game_arena_default = GameArena;

  // src/runes.js
  var CARET_RUNE = [[-7, 10], [0, -10], [7, 10]];
  var CIRCLE_RUNE = [[10, 0], [9, 4], [7, 7], [4, 9], [0, 10], [-4, 9], [-7, 7], [-9, 4], [-10, 0], [-9, -4], [-7, -7], [-4, -9], [0, -10], [4, -9], [7, -7], [9, -4], [10, 0]];
  var BOLT_RUNE = [[-5, -10], [5, -10], [-3, 0], [3, 0], [0, 10]];
  var TRIANGLE_RUNE = [[-9, -10], [9, -10], [0, 10], [-9, -10]];
  var WAVE_RUNE = [[-10, -4], [-5, 4], [0, -4], [5, 4], [10, -4]];
  var HOURGLASS_RUNE = [[-9, -8], [9, 8], [9, -8], [-9, 8], [-9, -8]];
  var SQUARE_SHAPE = [[-7, -7], [7, -7], [7, -7], [7, 7], [7, 7], [-7, 7], [-7, 7], [-7, -7]];
  var PLUS_SHAPE = [[-7, 0], [7, 0], [0, -7], [0, 7]];
  var EX_SHAPE = [[-7, -7], [7, 7], [-7, 7], [7, -7]];
  var HORIZONTAL_SHAPE = [[-7, 0], [7, 0]];
  var VERTICAL_SHAPE = [[0, -7], [0, 7]];
  var COLOR_MAP = {
    0: [0.4, 0.4, 0.4],
    1: [1, 0.3, 0.3],
    2: [0.3, 0.65, 1],
    3: [0.4, 1, 0.4],
    4: [1, 1, 0.3],
    5: [1, 0.65, 0.3],
    6: [1, 0.4, 1]
  };

  // src/powerup.js
  var SHAPES = [
    SQUARE_SHAPE,
    PLUS_SHAPE,
    EX_SHAPE,
    HORIZONTAL_SHAPE,
    VERTICAL_SHAPE
  ];
  var POWER_COLORS2 = [
    [230, 30, 30],
    [48, 128, 230],
    [16, 240, 16]
  ];
  function PowerUp(cx, cy, powerType, shapeType) {
    let anim = 0;
    let remove2 = false;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
        const color = POWER_COLORS2[powerType];
        ctx2.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx2.beginPath();
        ctx2.ellipse(0, 0, 18 + Math.cos(anim * 12) * 1, 18 - Math.cos(anim * 12) * 1, 0, 0, Math.PI * 2);
        ctx2.fill();
        for (let i = 0; i < 3; i++) {
          const p = (i * 30 + anim * 50) % 50 / 50;
          const q = 0.15 + p * 0.85;
          ctx2.beginPath();
          ctx2.ellipse((i * 30 + 20) % 24 - 12, -p * 36, 12 * (1 - p) * q, 16 * (1 - p) / q * p, 0, 0, Math.PI * 2);
          ctx2.fill();
        }
        ctx2.strokeStyle = WHITE;
        ctx2.lineWidth = 5;
        ctx2.beginPath();
        const shape = SHAPES[shapeType];
        for (let i = 0; i < shape.length; i++) {
          const pt = shape[i];
          if (i % 2 == 0) {
            ctx2.moveTo(pt[0], pt[1]);
          } else {
            ctx2.lineTo(pt[0], pt[1]);
          }
        }
        ctx2.stroke();
      });
    }
    function update(dT) {
      anim += dT;
      return remove2;
    }
    function onRunestoneMove([cx0, cy0, cx1, cy1]) {
      let distToHit = -1;
      let totalDist = Math.abs(cy1 - cy0) + Math.abs(cx1 - cx0);
      if (cx0 == cx && cx1 == cx && (cy >= cy0 && cy <= cy1 || cy >= cy1 && cy <= cy0)) {
        distToHit = Math.abs(cy - cy0);
      }
      if (cy0 == cy && cy1 == cy && (cx >= cx0 && cx <= cx1 || cx >= cx1 && cx <= cx0)) {
        distToHit = Math.abs(cx - cx0);
      }
      if (distToHit >= 0) {
        setTimeout(() => {
          add(pulse_sfx_default(cx, cy, 60, POWER_COLORS2[powerType]));
          remove2 = true;
          off(RUNESTONE_MOVE, onRunestoneMove);
          emit(POWERUP_ACQUIRED);
        }, distToHit / (totalDist + 0.01) * 600);
        setTimeout(() => {
          applyAbility(cx1, cy1);
        }, 660);
      }
    }
    function castPattern(a) {
      for (let i = 0; i < a.length; i++) {
        const x = a[i][0];
        const y = a[i][1];
        if (x < 0 || x >= 6 || y < 0 || y >= 6) {
          continue;
        }
        setTimeout(() => {
          add(ability_default(x, y, powerType));
        }, a[i][2]);
      }
    }
    function applyAbility(x, y) {
      if (shapeType == 0) {
        castPattern([
          [x - 1, y, 0],
          [x - 1, y - 1, 0],
          [x, y - 1, 0],
          [x + 1, y - 1, 0],
          [x + 1, y, 0],
          [x + 1, y + 1, 0],
          [x, y + 1, 0],
          [x - 1, y + 1, 0]
        ]);
      } else if (shapeType == 1) {
        castPattern([
          [x - 1, y, 0],
          [x, y - 1, 0],
          [x + 1, y, 0],
          [x, y + 1, 0],
          [x - 2, y, 300],
          [x, y - 2, 300],
          [x + 2, y, 300],
          [x, y + 2, 300]
        ]);
      } else if (shapeType == 2) {
        castPattern([
          [x - 1, y - 1, 0],
          [x + 1, y - 1, 0],
          [x - 1, y + 1, 0],
          [x + 1, y + 1, 0],
          [x - 2, y - 2, 300],
          [x + 2, y - 2, 300],
          [x - 2, y + 2, 300],
          [x + 2, y + 2, 300]
        ]);
      } else if (shapeType == 3) {
        castPattern([
          [x - 1, y, 0],
          [x - 2, y, 100],
          [x - 3, y, 200],
          [x - 4, y, 300],
          [x - 5, y, 400],
          [x + 1, y, 0],
          [x + 2, y, 100],
          [x + 3, y, 200],
          [x + 4, y, 300],
          [x + 5, y, 400]
        ]);
      } else if (shapeType == 4) {
        castPattern([
          [x, y - 1, 0],
          [x, y - 2, 100],
          [x, y - 3, 200],
          [x, y - 4, 300],
          [x, y - 5, 400],
          [x, y + 1, 0],
          [x, y + 2, 100],
          [x, y + 3, 200],
          [x, y + 4, 300],
          [x, y + 5, 400]
        ]);
      }
    }
    on(RUNESTONE_MOVE, onRunestoneMove);
    return {
      render,
      update,
      tags: ["obstacle"],
      order: 15,
      getX: () => cx,
      getY: () => cy
    };
  }
  var powerup_default = PowerUp;

  // src/rune-stone.js
  var ORDER_REMAP = { 5: 0, 1: 1, 3: 2, 2: 3, 4: 4, 6: 5 };
  var runeOrder = [
    CARET_RUNE,
    CIRCLE_RUNE,
    BOLT_RUNE,
    TRIANGLE_RUNE,
    WAVE_RUNE,
    HOURGLASS_RUNE
  ];
  function RuneStone() {
    let anim = 0;
    let cx = 0;
    let cy = 2;
    const mesh = [[-35, 0], [-15, 30], [15, 30], [35, 0], [15, -30], [-15, -30]];
    const MOVE_DURATION = 0.66;
    const IDLE = 0;
    const MOVING = 1;
    let state = IDLE;
    let timeInState = 0;
    let targetCX = 0;
    let targetCY = 0;
    let originCX = 0;
    let originCY = 0;
    function render(ctx2) {
      retainTransform(() => {
        for (let i = 0; i < 6; i++) {
          ctx2.lineWidth = 4;
          const SIZE = 80;
          if (pivot == 1) {
            ctx2.strokeStyle = WHITE;
          } else {
            ctx2.strokeStyle = "#ebbd91";
          }
          retainTransform(() => {
            ctx2.translate(-SIZE / 2, SIZE / 2 + SIZE * i);
            ctx2.scale(1.5, 1.5);
            renderLines(ctx2, runeOrder[i]);
          });
          if (pivot == 0) {
            ctx2.strokeStyle = WHITE;
          } else {
            ctx2.strokeStyle = "#ebbd91";
          }
          retainTransform(() => {
            ctx2.translate(SIZE / 2 + SIZE * i, SIZE * 6.5);
            ctx2.scale(1.5, 1.5);
            renderLines(ctx2, runeOrder[i]);
          });
        }
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80 + 4);
        ctx2.fillStyle = "rgba(0,0,0,0.13)";
        ctx2.beginPath();
        ctx2.ellipse(0, 0, 32, 22, 0, 0, 2 * Math.PI);
        ctx2.fill();
        if (state == MOVING) {
          const p = timeInState / MOVE_DURATION;
          ctx2.translate(0, -90 * p * (1 - p));
        }
        const angle = anim;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const xfmMesh = mesh.map((pt) => {
          return [
            (pt[0] * c + pt[1] * s) * 0.8,
            (-pt[0] * s * 0.6 + pt[1] * c * 0.6) * 0.8
          ];
        });
        ctx2.lineWidth = 10;
        ctx2.strokeStyle = DARK_GRAY;
        ctx2.fillStyle = GRAY;
        renderAndFill(ctx2, xfmMesh);
        ctx2.translate(0, -11);
        ctx2.lineWidth = 6;
        ctx2.beginPath();
        for (let i = 0; i < 6; i++) {
          const pt = mesh[i];
          const x = (pt[0] * c + pt[1] * s) * 0.83;
          const y = (-pt[0] * s * 0.6 + pt[1] * c * 0.6) * 0.83;
          ctx2.moveTo(x, y);
          ctx2.lineTo(x, y + 10);
        }
        ctx2.stroke();
        ctx2.lineWidth = 10;
        ctx2.fillStyle = GRAY;
        renderAndFill(ctx2, xfmMesh);
        ctx2.strokeStyle = "#fff";
        ctx2.beginPath();
        ctx2.lineWidth = 6;
        const DOTS = [[0, -7], [7, 6], [-7, 6]];
        for (let i = 0; i < 3; i++) {
          const pt = DOTS[i];
          const x = (pt[0] * c + pt[1] * s) * 1;
          const y = (-pt[0] * s * 0.6 + pt[1] * c * 0.6) * 1;
          ctx2.moveTo(x, y);
          ctx2.lineTo(x + 0.01, y);
        }
        ctx2.stroke();
      });
    }
    function update(dT) {
      timeInState += dT;
      if (state == MOVING) {
        const p = timeInState / MOVE_DURATION;
        anim = p * Math.PI * 2;
        cx = originCX * (1 - p) + targetCX * p;
        cy = originCY * (1 - p) + targetCY * p;
        if (p >= 1) {
          cx = targetCX;
          cy = targetCY;
          timeInState = IDLE;
          state = IDLE;
          anim = 0;
          emit(RUNESTONE_LAND);
          add(pulse_sfx_default(cx, cy, 50, [255, 255, 255]));
          setTimeout(() => {
            emit(TURN_END);
          }, 550);
        }
      }
    }
    function moveToDest(x, y) {
      originCX = cx;
      originCY = cy;
      targetCX = x;
      targetCY = y;
      state = MOVING;
      timeInState = 0;
      emit(RUNESTONE_MOVE, [originCX, originCY, targetCX, targetCY]);
    }
    let pivot = 0;
    function onSigilDrawn(idx) {
      if (idx == 0) {
        return;
      }
      const m = ORDER_REMAP[idx];
      if (pivot == 0) {
        moveToDest(m, cy);
        pivot = 1;
      } else {
        moveToDest(cx, m);
        pivot = 0;
      }
    }
    on(SIGIL_DRAWN, onSigilDrawn);
    return {
      update,
      render,
      tags: ["obstacle"],
      getX: () => cx,
      getY: () => cy
    };
  }
  var rune_stone_default = RuneStone;

  // ../rune-classifier/base64_encoded_model.txt
  var base64_encoded_model_default = "eJiYiIiJeIiIiXeIiIiXmXl3iXh5iIiHh3eJmXiIl5l3iHd4iIiIh3d4eZeIiIiHiIeJiXeJiIh4mJl3iHl5h5iHiYiIeIeYiIiYmIh3d4iHmIeIh5iJmYmXiIeXh3l4h3mYeXh5iXiIiJeIeJiXd3iYmXeJmId5h4mXd5eJiHiIiJmXeHl5iJiIh4eIiXiXiHiIiId3iIiIl5iIh3mYiYiIiIeHiHmId4h4l3d3d4iIiImJeIiIh4iHiIiYiXiJl5mIiIiJiYiYeHiIiZh4iZd3l5iYd4iIiHiJmZeXmJh4iImZiHh4iZiHiIiZmYd4eIiJh4h4eJh4h3d3eHiJh5d5d4d3iXeIeIiIeImIiYiHl5iIeYh5d4d4iHeIiXeIiHiIh3iHmJiIiIiIiJl4iIeIiIiIiYiImJiYiHh3h3eImZmXh5iIh6iYl3iJiXeIl5h3eZmIeIh4eId3iJl4h4iZeYiJh4iImXiYeHiZeIiJeXeIl5l4mYmYiIiIeIeIiIeHiXh3d4eId4mHmYl4iJiYh5iHeIiYmYiZiHiIiIiIiXmIiYd4h5iHh4h3d4iHiHiIh4h4h3d4iHmIiIiIiJiIh4h5iIeYmZiJiIiXiJmYeJiYiIiHiImHiImYiIl4eHeZiImJeHiImJiYh5h3mHmXeIh4d5h4eJmJiHh4h3iIeId3iYiHh5eXmYmIeImIeJeIh4d4h5mHd5iIiYiJd5eId3iHiIiHl4mIh4eYeIiZmYiHh5mHiJmIl4mId3iHd4iJh4d5l4d3eIh4iIiXiIiIiImIiHmImIh4iHeJiJmJiHiHeId4mHmJiHh4eIiId4l5mIiJiHiJiYiImXd3eIiIiYmIiYmYh4mImImIh3iId4d4d5eYd4iIl5iJh5eHd4eIeYeJl4iYmImJiXeHmYmIiIh4l4l4mJeHiIiId4mXmXeHmHmIiJmYmIiJiYl5iXiHh3eYiId4eIiIh4h4h3h4eIeHeId3h4iHiHh3iHiImImImImZiYiHmJiJiHiIiImId5d3mZeIh5h5h4iHiIiHeJiIiYl4mHiZiZiIiXmIl4mZh4mJiYh4iJiHiYh4iIeYl5eJiIiImImIiYeYiYiIiIeHeIl4h5iFeIiHeId4h4eIiIiIiIiIiImIeIiIeIiIiIiIiJiIiIiIiYiIiIiYeIiIiIiIiImIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiHeIiIeIiHiYeIiIiIiIiIh4h4iJiIiIiIeHiIiIiJiIiIiHiJiIh3iIh3iHiHiIiIeIiIeIiIiIh4iHiJiHeIiIh3eIh4iIh4h3iYiIiIiHiIiIiIiIeIiIeIiIiIiIiIiIiIiIeId4d4eYh3mHh4iHiIh4iIeYiJiIiIeIiYeHiIiHiIiIiIiIeHiJiIeIiIh4eIiHiHiHiIiZiImHmJiIh4iIiIiIh4iIiIiIiIiIeIiIiIiIiHh4mIiJiIiIiIiIiIiJmIiIiIiId4iHiIiIiIiIiJiIiHiIiIh4h4iIiImIiIiIiIh4iImIiIeIiIiIiIiIiIiIiHiIiIh4mIiIiImIiIiIeIh4h4iIh3iIiHmJiHiIiIiHiIh4h4iIiImIiImIiIiIiImIh4iYiJh4iIiImIh4iIiIeIh3iIiIiIiIh4iImIiIiYeIiIeHiIiYeIiIiIiId4iIiIiIiJiIeIiIiYiIiIiIeHiIiJiIeIeHiIh4iIiHiIiIiIiIiIh4iIiHiIiIeIiIiIiIh4eIiHh4iIeHh4h3iJiIiIiIiXd4iIiIeImIiIiIiJiIiIiIiImIiIiIiIiHh4iIiIh4iIiIiYeImImIiIh4eIiJiIiIiJeIiIiIiIiIiIiHiHeIiIiIiIiIiIiIh4iIiYh4h4h4iIiHiIeHeHiIiJiIh3iHmJiIh4iIiIeIh4iHmZmIiYiYh4iIiIiIeImHiIiIiHiImYeIiImIeIh3iHd3mIiIiHiHiImIiIiIiIeIeHeYiIl4iIiHh4iHh4h4iIiIiIiHiHiIeHeYh4iIeIiIiImImIiIiIh4eIiIiYiIiIiIiIiIiIeIiIiIiIiIiIiIiId4iIiJiIiIiIiIiIh4iYiIiIiIiIiIh4iIiJeIiIiIiIiIiIiYiYiJiJiXiIiIiIiIh4iHd5iIiZh5iJiYiIiIiIiIiIiIiHd4iHiIiIiIeJiIiIiIh3iImIiIiIiIiIiIiIiIiIiIh4l4iIiIiIiIiIeJiIiIiJeIiIiIiIiHiIl4eImIiIiIiIiYh3iIiIiIiIiImYeIiIiJiIiIiIiIiIiIiIiIiIeIiId4iYiIiIiIh4iHiIiIiIiImIiIiHiJiImIeIiIiIeImHiIiHiIiIiIiJd5iIiIiIiHiIiIiIiIiIiIiIiIiYiIiIiIiIiIiJiIiYeIiIiIiIiIeImIiIiIiHiIh4iIiIiJmIiIh3iIiIh4iIeIh4iIiIiIeIiIiIiIiIiIiIiIeIh4mIiHeIiYiJh4iIiHiIiIiIiIiHiIiYiIiIiIeIeZh4eHeIiIeIiJh4iIiHiIiIiIiIiIiHiIh3mIiHh4iIh4iJd4iHmIeIiHeIh4iYiIiIiIiImIh4iYiImIiIiJh4h4h4mIeIiHiIh4iIiHiIiIiJh4iIiIiIiYiYd5iIiHiHh4iHiIiIiHiIh4h3h4iIeYh4iIh4iIiHeIiIiIiIiIeIiJh4iIiHiJiIiIiIiIiIiImIeIiIiIiIiIiJiIiIiImIiIiIiIiImIiIiIiIh4iIiIeIiIiIiIh4iIiIh4iIiIiIiIiIiHh4h4iIiIiIiIiIiIeIiIiIiIiIh4iIiIiIiIiIiIiYiIh4eYiHiIiIiIiHiImIiJh4iIiIeJiHiHiIeHiIiIiHiIh4eIh4iHiId3iImHiIiId4iIiJiIeIeIeIiIiIiIiIiIiIiIiIiHiHh4eIiIh4mIiYiIiIiIiImHiIeIiIiHiIiIiJiIeIiIh4eIeIiIeIiHiIiHiIh4iIh4iIiIiXiJiIiImIiHiHiIiIiIh4iJiIiIiHiYiYmIiIiIh4iIiIeIiJiJiIiIiXiIh4h4iHiIh4mXh5iIeIiIiIiHiIiIiIiIeIiIiImIiIiIiIiIiIh4h3iHiHd4iYd4iJiImIiImIiJiIiIiIiIiIiIeJiImHiIiIeHh5iIiIiIiIiIiJiImYmImIl4iImIiJiJiIiIiIiHiJh4iIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIh4iIiIh4h4iHiIiGiIiIiIiIiIiIiIiJiIh4iIiIiIiIh4eIiHeIeIh4h4iJh3h3h4eJiIiIiIh4iIeIiIiIiHiIeImIiIiIiIiIiImYiIeIiIh4iYiIiIiIiHiIeIiIiIiIiIiIiIiXiIiIiIiIeIiIiIh4h3iIiHiYmJiIeIeIiHh2qXmYd4mJmImKd4l4mYmHiWmIl4iHiIe5mIhpmJl4eaiaqZd6aJeZqXh3iYiXaYiHqIqJiZVnenmHaJd3qXd2eZh5mJeYmHZWmXeHiGiZlpmZhomYmml2eJiHtnZ5l4mZiZiIdolpmphnmWd4mKmIhXd5aIh5h5Z6aIiZZqmYh5h3ipandpqXeGqHiZaXdnmYh5l5l4d4qZiXmpipiGeIaIlaeIiZqHmXl5imeYaHiZmHl3eIh3iVipl5aWephnh2eYh4iWiWiHiJeJeHiHh7pZiXiHZ4qWl5aZqZmIhnhoeXmIiWd4eaibaJl3l3Zpl3alh5maiIZ5aGeZh4l4iZiXl3l2eJeYh5h5iJmYmZhmeHhpiKeZlneWead6iXt6eKmXd5mniWeGlnmYiWipeYeFmYZ4eHmXmlaqh2iIiJlplpiJiIl4qYmIdoepiIl4mYp4iYeImIqZaaaIiZh5d3Z4";

  // src/rune-model.js
  var encodedWeights = atob(base64_encoded_model_default);
  var modelParams = [];
  for (let i = 0; i < 0 + 1 * encodedWeights.length; i++) {
    const a = encodedWeights.charCodeAt(i);
    modelParams.push(((a & 15) - 8) * 2.2 / 16, ((a >> 4 & 15) - 8) * 2.2 / 16);
  }
  function linearReluLayer(data, modelParams2, numOutputs, numInputs, x0, y0, span, stride, weightOffset, biasOffset) {
    const outputs = new Array(numOutputs);
    for (let i = 0; i < numOutputs; i++) {
      let acc = 0;
      for (let j = 0; j < numInputs; j++) {
        const inputIndex = y0 + j % span + stride * (x0 + Math.floor(j / span));
        const weightIndex = weightOffset + i * numInputs + j;
        acc += modelParams2[weightIndex] * data[inputIndex];
      }
      const biasIndex = i + biasOffset + weightOffset;
      outputs[i] = Math.max(0, modelParams2[biasIndex] + acc);
    }
    return outputs;
  }
  function layerNorm(t) {
    const mean = t.reduce((acc, val) => acc + val, 0) / t.length;
    const variance = t.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / t.length;
    return t.map((val) => (val - mean) / Math.sqrt(variance + 1e-3));
  }
  function classify(data) {
    const BASE_PATCH = 7 * 7;
    const PATCH_FEATURES = 34;
    const PATCH_FEATURES_DEEP = 25;
    const NUM_CLASSES = 7;
    x11 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x12 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x13 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x14 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x21 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x22 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x23 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x24 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x31 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x32 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x33 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x34 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x41 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x42 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x43 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x44 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    y11 = layerNorm(linearReluLayer(
      x11.concat(x12, x21, x22),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y12 = layerNorm(linearReluLayer(
      x13.concat(x14, x23, x24),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y21 = layerNorm(linearReluLayer(
      x31.concat(x32, x41, x42),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y22 = layerNorm(linearReluLayer(
      x33.concat(x34, x43, x44),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    z = linearReluLayer(
      y11.concat(y12, y21, y22),
      modelParams,
      NUM_CLASSES,
      4 * PATCH_FEATURES_DEEP,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES + 4 * PATCH_FEATURES * PATCH_FEATURES_DEEP + PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES_DEEP * NUM_CLASSES
    );
    return z;
  }

  // src/spell-caster.js
  function SpellCaster() {
    const scaledCanvas = document.createElement("canvas");
    const scaledCtx = scaledCanvas.getContext("2d");
    const grayscaleArray = new Array(28 * 28);
    const mapping = {
      0: "garbage",
      1: "circle",
      2: "triangle",
      3: "bolt",
      4: "wave",
      5: "caret",
      6: "hourglass"
    };
    const lines = [];
    let isDrawing = false;
    let selectedLines = [];
    let selectedClass = -1;
    let timeSinceSelect = 0;
    function touchifyEvent(evt) {
      const touches = evt.changedTouches;
      if (touches) {
        evt.clientX = touches[0].clientX;
        evt.clientY = touches[0].clientY;
      }
    }
    function onMouseDown(evt) {
      touchifyEvent(evt);
      selectedClass = -1;
      if (evt.clientY < canvas.height * 0.65 - 5) {
        return;
      }
      lines.length = 0;
      lines.push([evt.clientX, evt.clientY]);
      isDrawing = true;
    }
    function onMouseMove(evt) {
      touchifyEvent(evt);
      if (isDrawing && lines.length > 0) {
        const latestPt = lines[lines.length - 1];
        let dx = evt.clientX - latestPt[0];
        let dy = evt.clientY - latestPt[1];
        if (evt.clientY < canvas.height * 0.65 - 5) {
          return;
        }
        if (dx * dx + dy * dy > 20) {
          lines.push([evt.clientX, evt.clientY]);
        }
      }
    }
    function onMouseUp(evt) {
      touchifyEvent(evt);
      if (lines.length == 0) {
        return;
      }
      selectedClass = classifyDrawing();
      selectedLines = JSON.parse(JSON.stringify(lines));
      timeSinceSelect = 0;
      lines.length = 0;
      isDrawing = false;
      emit(SIGIL_DRAWN, selectedClass);
    }
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("touchstart", onMouseDown);
    window.addEventListener("touchmove", onMouseMove);
    window.addEventListener("touchend", onMouseUp);
    function classifyDrawing() {
      let mins = [Infinity, Infinity];
      let maxs = [-Infinity, -Infinity];
      lines.map((pt) => {
        mins[0] = Math.min(pt[0], mins[0]);
        mins[1] = Math.min(pt[1], mins[1]);
        maxs[0] = Math.max(pt[0], maxs[0]);
        maxs[1] = Math.max(pt[1], maxs[1]);
      });
      let normalizeLines = [];
      let size = Math.max(maxs[0] - mins[0], maxs[1] - mins[1]);
      if (size < 70) {
        return 0;
      }
      size = Math.max(size, 100);
      const tracker = {};
      let topPred = 0;
      let topVal = 0;
      for (let i = 0; i < 20; i++) {
        normalizeLines = [];
        const SKX = Math.random() * 3 + 16;
        const SKY = Math.random() * 3 + 16;
        lines.map((pt) => {
          normalizeLines.push([
            (pt[0] - (maxs[0] + mins[0]) / 2) / size * SKX,
            (pt[1] - (maxs[1] + mins[1]) / 2) / size * SKY
          ]);
        });
        scaledCtx.setTransform(1, 0, 0, 1, 0, 0);
        scaledCtx.clearRect(0, 0, 28, 28);
        scaledCtx.strokeStyle = "white";
        scaledCtx.lineWidth = Math.random() * 0.5 + 1.3;
        scaledCtx.lineJoin = "round";
        scaledCtx.lineCap = "round";
        scaledCtx.setTransform(
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 2 + 14,
          (Math.random() - 0.5) * 2 + 14
        );
        renderLines(scaledCtx, normalizeLines);
        const scaledImage = scaledCtx.getImageData(0, 0, 28, 28);
        const pixelData = scaledImage.data;
        for (let i2 = 0; i2 < pixelData.length; i2 += 4) {
          grayscaleArray[i2 >> 2] = pixelData[i2] / 255;
        }
        const z2 = classify(grayscaleArray);
        const argmax = (arr) => arr.reduce((iMax, x, i2, arr2) => x > arr2[iMax] ? i2 : iMax, 0);
        const prediction = argmax(z2);
        if (tracker[prediction] === void 0) {
          tracker[prediction] = 0;
        }
        tracker[prediction] += 1;
        const v = tracker[prediction];
        if (v > topVal) {
          topVal = v;
          topPred = prediction;
        }
      }
      return topPred;
    }
    function render(ctx2) {
      retainTransform(() => {
        ctx2.setTransform(1, 0, 0, 1, 0, 0);
        ctx2.fillStyle = DARK_GRAY;
        ctx2.fillRect(0, canvas.height * 0.65, canvas.width, canvas.height * 0.36);
        ctx2.strokeStyle = BLACK;
        ctx2.lineWidth = 10;
        renderLines(ctx2, [[0, canvas.height * 0.65], [canvas.width, canvas.height * 0.65]]);
        if (isDrawing) {
          ctx2.strokeStyle = "white";
          ctx2.lineWidth = 20;
          renderLines(ctx2, lines);
        }
        if (selectedClass != -1) {
          const p = Math.exp(-timeSinceSelect * 3) * 2;
          const c = COLOR_MAP[selectedClass];
          ctx2.strokeStyle = `rgba(${c[0] * 255}, ${c[1] * 255}, ${c[2] * 255}, ${p * 0.6})`;
          ctx2.lineWidth = 20 + (1 - Math.exp(-timeSinceSelect * 5)) * 80;
          renderLines(ctx2, selectedLines);
          ctx2.strokeStyle = `rgba(${c[0] * 300}, ${c[1] * 300}, ${c[2] * 300}, ${p})`;
          ctx2.lineWidth = 20;
          renderLines(ctx2, selectedLines);
        }
      });
    }
    function update(dT) {
      timeSinceSelect += dT;
      if (selectedClass != -1 && timeSinceSelect < 5) {
        selectedLines.map((pt, i) => {
          pt[0] += Math.cos(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
          pt[1] += Math.sin(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
        });
      }
    }
    return {
      update,
      render
    };
  }
  var spell_caster_default = SpellCaster;

  // src/wizard.js
  function Wizard() {
    let anim = 0;
    let hp = 10;
    let dead = false;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate(-120, 160);
        if (hp > 0) {
          ctx2.fillStyle = "#f11";
          ctx2.textAlign = "center";
          ctx2.font = `bold 30px arial`;
          ctx2.fillText(`${hp} HP`, 0, 230);
        }
        ctx2.fillStyle = GRAY;
        ctx2.strokeStyle = DARK_GRAY;
        ctx2.lineWidth = 10;
        for (let i = 0; i < 4; i++) {
          ctx2.translate(0, 20);
          renderAndFill(ctx2, [[-30, 0], [-15, 10], [-15, 30], [-30, 20]]);
          renderAndFill(ctx2, [[-15, 10], [15, 10], [30, 0], [30, 20], [15, 30], [-15, 30]]);
          ctx2.translate(0, 20);
          renderAndFill(ctx2, [[-30, 0], [-15, 10], [15, 10], [15, 30], [-15, 30], [-30, 20]]);
          renderAndFill(ctx2, [[15, 10], [30, 0], [30, 20], [15, 30]]);
        }
        ctx2.translate(0, -143);
        ctx2.fillStyle = MID_GRAY;
        renderAndFill(ctx2, [[-30, 0], [-15, 10], [15, 10], [30, 0], [15, -10], [-15, -10]]);
        if (hp > 0) {
          ctx2.translate(3, -2);
          ctx2.fillStyle = BLACK;
          ctx2.strokeStyle = BLACK;
          ctx2.lineWidth = 4;
          const squeeze = -Math.cos(anim * 10) * 0.05 + 0.95;
          renderAndFill(ctx2, [[-20 * squeeze, 0], [12 * squeeze, 0], [1 * squeeze, -30], [-10 * squeeze, -10]]);
          ctx2.fillStyle = PURPLE;
          ctx2.strokeStyle = PURPLE;
          ctx2.translate(0, -23 + Math.abs(Math.sin(anim * 5) * 2.5));
          ctx2.rotate(Math.sin(anim * 10 - 1) * 0.06);
          renderAndFill(ctx2, [[-20, 2], [-10, -1], [13, 0], [20, 4], [17, 0], [12, -5], [7, -13], [0, -23], [-10, -29], [-21, -20], [-12, -22], [-6, -10]]);
          ctx2.lineWidth = 7;
          ctx2.strokeStyle = WHITE;
          renderLines(ctx2, [[8, -4], [8.01, -4]]);
          renderLines(ctx2, [[-1, -4], [-1.01, -4]]);
          renderLines(ctx2, [[2, -11], [2.01, -11]]);
        }
      });
    }
    function update(dT) {
      anim += dT;
    }
    function onEnemyDamage(dmg) {
      hp -= dmg;
      if (hp <= 0) {
        hp = 0;
        if (!dead) {
          dead = true;
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              add(pulse_sfx_default(-2, 1.5, 70, [255, 255, 255]));
            }, i * 400);
          }
        }
      }
    }
    on(ENEMY_DAMAGE, onEnemyDamage);
    return {
      update,
      render
    };
  }
  var wizard_default = Wizard;

  // src/main.js
  function initialize() {
    add(game_arena_default());
    add(wizard_default());
    add(rune_stone_default());
    add(spell_caster_default());
    add(enemy_spawner_default());
    function placePowerUp() {
      const powerType = Math.floor(Math.random() * 3);
      const shapeType = Math.floor(Math.random() * 5);
      for (let i = 0; i < 300; i++) {
        const sx = Math.floor(Math.random() * 4 + 1);
        const sy = Math.floor(Math.random() * 4 + 1);
        if (!spotOccupied(sx, sy)) {
          add(powerup_default(sx, sy, powerType, shapeType));
          return;
        }
      }
      console.log("Failed to place!");
    }
    placePowerUp();
    placePowerUp();
    placePowerUp();
    on(POWERUP_ACQUIRED, placePowerUp);
  }
  initialize();
})();
</script>