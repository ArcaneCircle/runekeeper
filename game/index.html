<html><title>Runekeeper</title><link rel="shortcut icon"/><style>body{overflow:hidden;background:#000;margin:0px;font-family:sans-serif;}h1{color:#fff;text-align:center;margin-top:30px;}img{position:fixed;top:280px;width:600px;left:50%;margin-left:-300px;}h2{color:#666;font-style:italic;text-align:center;}</style><canvas></canvas><script>(() => {
  // src/bus.js
  var HANDLES = {};
  function on(e, handler) {
    (HANDLES[e] || (HANDLES[e] = [])).push(handler);
  }
  function off(e, handler) {
    HANDLES[e] = (HANDLES[e] || []).filter((x) => x != handler);
  }
  function emit(e, data) {
    (HANDLES[e] || []).map((handler) => handler(data));
  }

  // src/canvas.js
  var canvas = document.getElementsByTagName("canvas")[0];
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    ctx.imageSmoothingEnabled = false;
  };
  var ctx;
  function retainTransform(fn) {
    const xfm = ctx.getTransform();
    fn();
    ctx.setTransform(xfm);
  }
  function renderLines(ctx2, lines, close = false) {
    ctx2.beginPath();
    lines.map((pt, i) => {
      if (i == 0) {
        ctx2.moveTo(pt[0], pt[1]);
      } else {
        ctx2.lineTo(pt[0], pt[1]);
      }
    });
    if (close) {
      ctx2.closePath();
    }
    ctx2.stroke();
  }
  function renderAndFill(ctx2, lines) {
    renderLines(ctx2, lines, true);
    ctx2.fill();
  }
  var favicon = document.createElement("canvas");
  favicon.width = favicon.height = 64;
  ctx = favicon.getContext("2d");
  ctx = canvas.getContext("2d");
  var link = document.querySelector("link");
  link.href = favicon.toDataURL();
  ctx.imageSmoothingEnabled = false;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // src/color.js
  var LIGHT_BROWN = "#dbad81";
  var PURPLE = "#683492";
  var BLACK = "#000";
  var DARK_GRAY = "#474747";
  var GRAY = "#777";
  var MID_GRAY = "#a4a4a4";
  var LIGHT_GRAY = "#cbcbcb";
  var WHITE = "#fff";

  // src/damage-particle.js
  function DamageParticle(cx, cy, dmg, color) {
    let anim = 0;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.3) * 80 - (1 - Math.exp(-anim * 5)) * 70);
        const alpha = 1 - anim / 2;
        ctx2.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha})`;
        ctx2.textAlign = "center";
        ctx2.font = `bold 40px arial`;
        ctx2.fillText(`-${dmg}`, 0, 0);
      });
    }
    function update(dT) {
      anim += dT;
      if (anim > 2) {
        return true;
      }
    }
    return {
      update,
      render,
      order: 100
    };
  }
  var damage_particle_default = DamageParticle;

  // src/tags.js
  var TAG_CAMERA = 0;

  // src/engine.js
  var gameObjects = [];
  var gameObjectsByTag = {};
  var objectsToRemove = [];
  var lastFrameMs = 0;
  function tick(currentFrameMs) {
    const dT = Math.min((currentFrameMs - lastFrameMs) * 1e-3, 0.018);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    const zoom = Math.min(
      canvas.width / 800,
      canvas.height / 1100
    );
    ctx.setTransform(zoom, 0, 0, zoom, canvas.width / 2 - 190 * zoom, canvas.height * 0.3 - 80 * 6 * 0.5 * zoom);
    retainTransform(() => {
      const camera = getObjectsByTag(TAG_CAMERA)[0];
      if (camera) {
        camera.set(ctx);
      }
      objectsToRemove.length = 0;
      gameObjects.map((g) => {
        if (g.update?.(dT)) {
          objectsToRemove.push(g);
        }
      });
      if (objectsToRemove.length) {
        remove(objectsToRemove);
      }
      if (camera) {
        gameObjects.map((g) => {
          if (g.inView(camera.x, camera.y)) {
            g.render?.(ctx);
          }
        });
      } else {
        gameObjects.map((g) => {
          g.render?.(ctx);
        });
      }
      lastFrameMs = currentFrameMs;
    });
    requestAnimationFrame(tick);
  }
  function add(obj) {
    if (!obj.inView) {
      obj.inView = () => 1;
    }
    gameObjects.push(obj);
    resort();
    obj.tags?.map((tag) => {
      gameObjectsByTag[tag] = gameObjectsByTag[tag] ?? [];
      gameObjectsByTag[tag].push(obj);
    });
  }
  function resort() {
    gameObjects.sort((a, b) => (a.order || 0) - (b.order || 0));
  }
  function arrayRemove(list, valuesToEvict) {
    return list.filter((g) => !valuesToEvict.includes(g));
  }
  function remove(objList) {
    gameObjects = arrayRemove(gameObjects, objList);
    objList.map((obj) => {
      obj.tags?.map((tag) => {
        gameObjectsByTag[tag] = arrayRemove(gameObjectsByTag[tag], [obj]);
      });
    });
  }
  function getObjectsByTag(tag) {
    return gameObjectsByTag[tag] || [];
  }
  requestAnimationFrame(tick);

  // src/events.js
  var SIGIL_DRAWN = 0;
  var RUNESTONE_MOVE = 1;
  var POWERUP_ACQUIRED = 2;
  var RUNESTONE_LAND = 3;
  var TURN_END = 4;
  var ABILITY_USE = 5;
  var ENEMY_DAMAGE = 6;
  var ENEMY_BONK = 7;
  var ABILITY_BEAT = 8;
  var ENEMY_TAKE_DAMAGE = 9;
  var ENEMY_MOVE = 10;
  var SCORED = 11;
  var GAME_OVER = 12;

  // src/pulse-sfx.js
  function PulseSFX(cx, cy, scale, rgb) {
    let t = 0;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
        const p = t / 0.5;
        const r = scale * (1 - Math.exp(-p * 4));
        const alpha = 1 - p;
        ctx2.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
        ctx2.lineWidth = 12 * (1 - p);
        ctx2.beginPath();
        ctx2.ellipse(0, 0, r, r * 0.8, 0, 0, Math.PI * 2);
        ctx2.stroke();
      });
    }
    function update(dT) {
      t += dT;
      return t > 0.5;
    }
    return {
      render,
      update,
      order: 15
    };
  }
  var pulse_sfx_default = PulseSFX;

  // src/sensor.js
  function findObstacles() {
    return getObjectsByTag("obstacle");
  }
  function spotOccupied(x, y) {
    const obstacles = findObstacles();
    for (let i = 0; i < obstacles.length; i++) {
      const obs = obstacles[i];
      if (obs.getX() == x && obs.getY() == y) {
        return true;
      }
    }
    return false;
  }
  function spotHasEnemy(x, y) {
    const obstacles = getObjectsByTag("enemy");
    for (let i = 0; i < obstacles.length; i++) {
      const obs = obstacles[i];
      if (obs.getX() == x && obs.getY() == y) {
        return true;
      }
    }
    return false;
  }

  // src/enemy.js
  function Enemy(cx, cy, enemyType) {
    let anim = Math.random() * 7;
    let targetX = cx;
    let targetY = cy;
    let originX = cx;
    let originY = cy;
    const MOVE_DURATION = 0.35;
    let self = {};
    const IDLE = 0;
    const MOVING = 1;
    const ATTACK = 2;
    let state = IDLE;
    let timeInState = 0;
    let dead = false;
    let hp = [1, 2, 3][enemyType];
    let maxHp = hp;
    let motion = 0;
    let motionMax = [2, 2, 2][enemyType];
    let onFire = 0;
    add(pulse_sfx_default(cx, cy, 55, [0, 0, 0]));
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
        ctx2.fillStyle = "rgba(0,0,0,0.1)";
        ctx2.beginPath();
        ctx2.ellipse(0, 0, 26, 19, 0, 0, 2 * Math.PI);
        ctx2.fill();
        if (state == MOVING) {
          const p = timeInState / MOVE_DURATION;
          ctx2.translate(0, -120 * p * (1 - p));
        }
        ctx2.lineWidth = 10;
        if (enemyType == 0) {
          ctx2.fillStyle = "#973";
          ctx2.strokeStyle = "#973";
        } else if (enemyType == 1) {
          ctx2.fillStyle = GRAY;
          ctx2.strokeStyle = GRAY;
        } else if (enemyType == 2) {
          ctx2.fillStyle = "#383";
          ctx2.strokeStyle = "#383";
        }
        const squish = Math.cos(anim * 10);
        const squish2 = Math.cos(anim * 10 + 1);
        ctx2.fillRect(-10 + squish, 0, 20 - 2 * squish, -34 - 2 * squish);
        ctx2.strokeRect(-10 + squish, 0, 20 - 2 * squish, -34 - 2 * squish);
        retainTransform(() => {
          ctx2.translate(0, -39 - squish * 3);
          if (enemyType == 0) {
            ctx2.fillStyle = "#763";
            ctx2.strokeStyle = "#763";
            ctx2.fillRect(-6, 0, 12, -16);
            ctx2.strokeRect(-6, 0, 12, -16);
            ctx2.strokeStyle = LIGHT_GRAY;
            ctx2.beginPath();
            ctx2.moveTo(-3, -49 + 41);
            ctx2.lineTo(-3.01, -49 + 41);
            ctx2.stroke();
          } else if (enemyType == 1) {
            ctx2.fillStyle = DARK_GRAY;
            ctx2.strokeStyle = DARK_GRAY;
            ctx2.fillRect(-6, 0, 12, -16);
            ctx2.strokeRect(-6, 0, 12, -16);
            ctx2.strokeStyle = "#c11";
            ctx2.beginPath();
            ctx2.moveTo(0, -62 + 41);
            ctx2.lineTo(1, -70 + 41);
            ctx2.lineTo(6, -74 + 41);
            ctx2.lineTo(10, -70 + 41);
            ctx2.stroke();
            ctx2.strokeStyle = LIGHT_GRAY;
            ctx2.beginPath();
            ctx2.moveTo(-3, -49 + 41);
            ctx2.lineTo(-3.01, -49 + 41);
            ctx2.stroke();
          } else if (enemyType == 2) {
            ctx2.strokeStyle = "#eee";
            ctx2.beginPath();
            ctx2.moveTo(-8, -20);
            ctx2.lineTo(-12, -24);
            ctx2.stroke();
            ctx2.fillStyle = "#263";
            ctx2.strokeStyle = "#263";
            ctx2.fillRect(-6, 0, 12, -16);
            ctx2.strokeRect(-6, 0, 12, -16);
            ctx2.strokeStyle = "#fa0";
            ctx2.beginPath();
            ctx2.moveTo(-3, -49 + 41);
            ctx2.lineTo(-3.01, -49 + 41);
            ctx2.stroke();
            ctx2.strokeStyle = "#eee";
            ctx2.beginPath();
            ctx2.moveTo(8, -20);
            ctx2.lineTo(12, -24);
            ctx2.stroke();
          }
        });
        retainTransform(() => {
          ctx2.translate(-20, -18 + squish2 * 1);
          ctx2.rotate(Math.cos(anim * 10 - 0.2) * 0.04);
          if (state == ATTACK) {
            ctx2.translate(-Math.exp(-Math.pow((timeInState - 0.25) * 1.5, 2) * 25) * 20, 0);
            ctx2.rotate(-Math.exp(-Math.pow((timeInState - 0.3) * 1.5, 2) * 30) * 1.2);
          }
          if (enemyType == 0) {
            ctx2.rotate(-0.2);
            ctx2.strokeStyle = "#841";
            ctx2.beginPath();
            ctx2.moveTo(0, -30);
            ctx2.lineTo(0, 16);
            ctx2.stroke();
            ctx2.strokeStyle = "#eee";
            ctx2.beginPath();
            ctx2.moveTo(-2, -26);
            ctx2.lineTo(0, -30);
            ctx2.lineTo(2, -26);
            ctx2.stroke();
          } else if (enemyType == 1) {
            ctx2.strokeStyle = "#eee";
            ctx2.beginPath();
            ctx2.moveTo(0, 0);
            ctx2.lineTo(-6, -45 + 13);
            ctx2.stroke();
            ctx2.strokeStyle = "#841";
            ctx2.beginPath();
            ctx2.moveTo(-5, 0);
            ctx2.lineTo(5, -3);
            ctx2.moveTo(0, 0);
            ctx2.lineTo(2, 4);
            ctx2.stroke();
          } else if (enemyType == 2) {
            ctx2.translate(-4, 0);
            ctx2.rotate(-0.2);
            ctx2.strokeStyle = "#841";
            ctx2.beginPath();
            ctx2.moveTo(0, -20);
            ctx2.lineTo(0, 8);
            ctx2.stroke();
            ctx2.fillStyle = "#99b";
            ctx2.beginPath();
            ctx2.ellipse(0, -20, 14, 14, 0, 0, Math.PI * 2);
            ctx2.fill();
            ctx2.lineWidth = 5;
            ctx2.strokeStyle = "#77a";
            ctx2.beginPath();
            ctx2.moveTo(11, -20);
            ctx2.lineTo(16, -20);
            ctx2.moveTo(-11, -20);
            ctx2.lineTo(-16, -20);
            ctx2.moveTo(0, -31);
            ctx2.lineTo(0, -36);
            ctx2.stroke();
          }
        });
        if (motion == -1) {
          for (let i = 0; i < 8; i++) {
            const p = (i * 30 + anim * 40) % 50 / 50;
            const w = 1 - p * p * p * p * p;
            ctx2.fillStyle = `rgba(${250 - 150 * p}, ${250 - p * 150}, ${255}, ${(1 - p * p) * p * 4})`;
            retainTransform(() => {
              ctx2.beginPath();
              ctx2.translate((i * 83 % 130 - 65) * 0.34, p * 30 + (i * 17 % 23 - 25) * 2.6);
              ctx2.rotate(i + p * 3.5);
              ctx2.fillRect(-6, -6, 12, 12);
              ctx2.fill();
            });
          }
        }
        if (onFire > 0) {
          for (let i = 0; i < 9; i++) {
            const p = (i * 30 + anim * 100) % 50 / 50;
            const q = 0.15 + p * 0.85;
            const w = 1 - p * p * p * p * p;
            ctx2.fillStyle = `rgba(${255 * w}, ${(50 + p * 200) * w}, ${30 * w}, ${1 - p})`;
            ctx2.beginPath();
            ctx2.ellipse(
              (i * 83 % 130 - 65) * 0.34,
              -p * 56 + (i * 11 % 23 - 5) * 1.3,
              26 * (1 - p) * q,
              26 * (1 - p) / q * p,
              0,
              0,
              Math.PI * 2
            );
            ctx2.fill();
          }
        }
        for (let i = 0; i < maxHp; i++) {
          retainTransform(() => {
            ctx2.translate(-22 * (maxHp - 1) / 2 + 22 * i, 0);
            ctx2.beginPath();
            ctx2.strokeStyle = "#222";
            ctx2.lineWidth = 10;
            ctx2.moveTo(-5, 10);
            ctx2.lineTo(0, 15);
            ctx2.lineTo(5, 10);
            ctx2.stroke();
            if (i < hp) {
              ctx2.strokeStyle = "#f22";
              ctx2.lineWidth = 6;
              ctx2.stroke();
            }
          });
        }
        for (let i = 0; i < motionMax; i++) {
          retainTransform(() => {
            ctx2.translate(-22 * (motionMax - 1) / 2 + 22 * i, 0);
            ctx2.beginPath();
            ctx2.strokeStyle = "#222";
            ctx2.lineWidth = 10;
            ctx2.moveTo(-4, 27);
            ctx2.lineTo(4, 27);
            ctx2.stroke();
            if (i < motion || i <= motion && Math.cos(anim * 15) > 0) {
              ctx2.strokeStyle = "#3af";
              ctx2.lineWidth = 6;
              ctx2.stroke();
            }
          });
        }
      });
    }
    function update(dT) {
      if (motion == -1) {
        anim += dT * 0.4;
      } else {
        anim += dT * 1.52;
      }
      timeInState += dT;
      if (state == MOVING) {
        const p = timeInState / MOVE_DURATION;
        cx = originX * (1 - p) + targetX * p;
        cy = originY * (1 - p) + targetY * p;
        if (timeInState > MOVE_DURATION) {
          cx = targetX;
          cy = targetY;
          timeInState = 0;
          state = IDLE;
          self.order = 30 + cy * 0.02;
          resort();
        }
      }
      if (state == ATTACK && timeInState > 0.5) {
        state = IDLE;
        timeInState = 0;
      }
      if (dead) {
        off(RUNESTONE_MOVE, onRunestoneMove);
        off(TURN_END, onTurnEnd);
        off(ABILITY_USE, onAbilityUse);
        emit(SCORED);
        return true;
      }
    }
    function issueMove(nx, ny) {
      originX = cx;
      originY = cy;
      targetX = nx;
      targetY = ny;
      state = MOVING;
      timeInState = 0;
      emit(ENEMY_MOVE);
    }
    function onRunestoneMove() {
      motion += 1;
    }
    function onTurnEnd() {
      if (cx > 0) {
        if (motion >= motionMax) {
          const options = [[cx - 1, cy]];
          if (Math.random() > 0.5) {
            options.push([cx - 1, cy - 1]);
            options.push([cx - 1, cy + 1]);
          } else {
            options.push([cx - 1, cy + 1]);
            options.push([cx - 1, cy - 1]);
          }
          if (Math.random() > 0.5) {
            options.push([cx, cy - 1]);
            options.push([cx, cy + 1]);
          } else {
            options.push([cx, cy + 1]);
            options.push([cx, cy - 1]);
          }
          if (Math.random() > 0.5) {
            options.push([cx + 1, cy - 1]);
            options.push([cx + 1, cy + 1]);
          } else {
            options.push([cx + 1, cy + 1]);
            options.push([cx + 1, cy - 1]);
          }
          setTimeout(() => {
            for (let i = 0; i < options.length; i++) {
              const opt = options[i];
              if (opt[1] >= 0 && opt[1] <= 5 && opt[0] <= 5 && !spotOccupied(opt[0], opt[1])) {
                motion = 0;
                issueMove(opt[0], opt[1]);
                break;
              }
            }
          }, cy * 30 + cx * 25);
        }
      } else {
        state = ATTACK;
        timeInState = 0;
        emit(ENEMY_DAMAGE, 1);
        add(damage_particle_default(-1.1, cy + 0.5, 1, [255, 0, 0]));
      }
      if (onFire > 0) {
        onFire -= 1;
        takeDamage(1);
      }
    }
    function takeDamage(dmg) {
      hp -= dmg;
      add(pulse_sfx_default(cx, cy, 95, [0, 0, 0]));
      add(damage_particle_default(cx, cy, dmg, [255, 0, 0]));
      emit(ENEMY_TAKE_DAMAGE);
      if (hp <= 0) {
        dead = true;
      }
    }
    function onAbilityUse([tx, ty, powerType]) {
      if (tx == cx && ty == cy) {
        if (powerType == 0) {
          onFire = 3;
        }
        if (powerType == 1) {
          motion = -1;
          takeDamage(1);
        }
        if (powerType == 2) {
          takeDamage(2);
        }
      }
    }
    on(RUNESTONE_MOVE, onRunestoneMove);
    on(TURN_END, onTurnEnd);
    on(ABILITY_USE, onAbilityUse);
    self = {
      update,
      render,
      tags: ["enemy", "obstacle"],
      order: 30,
      getX: () => targetX,
      getY: () => targetY
    };
    self.order = 30 + cy * 0.02;
    resort();
    issueMove(cx - 1, cy);
    return self;
  }
  var enemy_default = Enemy;

  // src/enemy-spawner.js
  function EnemySpawner() {
    function render(ctx2) {
    }
    function update(dT) {
    }
    function spawnOne() {
      const enemies = getObjectsByTag("enemy");
      if (enemies.length < 3) {
        const MAX_ALLOWED = parseInt(Math.min(getObjectsByTag("game")[0].getScore() / 4, 2));
        const enemyType = parseInt(Math.min(Math.floor(Math.random() * (MAX_ALLOWED + 1)), MAX_ALLOWED));
        console.log(enemyType);
        for (let i = 0; i < 30; i++) {
          const offerY = Math.floor(Math.random() * 6);
          if (!spotOccupied(5, offerY)) {
            add(enemy_default(6, offerY, enemyType));
            break;
          }
        }
      }
    }
    function onTurnEnd() {
      spawnOne();
    }
    on(TURN_END, onTurnEnd);
    spawnOne();
    return {
      update,
      render
    };
  }
  var enemy_spawner_default = EnemySpawner;

  // src/game-arena.js
  function GameArena() {
    let score = 0;
    let gameOver = false;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.setTransform(1, 0, 0, 1, 0, 0);
        ctx2.fillStyle = LIGHT_BROWN;
        ctx2.fillRect(0, 0, canvas.width, canvas.height);
      });
      ctx2.strokeStyle = "#fbcda1";
      ctx2.lineWidth = 4;
      ctx2.beginPath();
      const SIZE = 80;
      for (let x = 0; x <= 6; x++) {
        ctx2.moveTo(x * SIZE, 0);
        ctx2.lineTo(x * SIZE, 6 * SIZE);
        ctx2.moveTo(0, x * SIZE);
        ctx2.lineTo(6 * SIZE, x * SIZE);
      }
      ctx2.stroke();
      if (!gameOver) {
        ctx2.fillStyle = "#222";
        ctx2.textAlign = "center";
        ctx2.font = `bold 30px arial`;
        ctx2.fillText(`${score} ${score == 1 ? "ENEMY" : "ENEMIES"} SLAIN`, SIZE * 3, -SIZE * 0.4);
      } else {
        ctx2.fillStyle = "#f00";
        ctx2.textAlign = "center";
        ctx2.font = `bold 30px arial`;
        ctx2.fillText(`GAME OVER! (score = ${score})`, SIZE * 3, -SIZE * 0.4);
      }
    }
    function update(dT) {
    }
    function onScored() {
      score += 1;
    }
    function onGG() {
      gameOver = true;
    }
    on(SCORED, onScored);
    on(GAME_OVER, onGG);
    return {
      update,
      render,
      order: -20,
      tags: ["game"],
      getScore: () => score
    };
  }
  var game_arena_default = GameArena;

  // src/ability.js
  var POWER_COLORS = [
    [230, 30, 30],
    [48, 128, 230],
    [106, 250, 106]
  ];
  function Ability(cx, cy, powerType) {
    let anim = Math.random() * 5;
    let t = 0;
    let renderOrder = 50;
    if (powerType == 1) {
      renderOrder = 10;
    }
    add(pulse_sfx_default(cx, cy, 55, POWER_COLORS[powerType]));
    emit(ABILITY_USE, [cx, cy, powerType]);
    function update(dT) {
      anim += dT;
      t += dT * 1;
      if (t > 1) {
        return true;
      }
    }
    function render(ctx2) {
      if (powerType == 0) {
        retainTransform(() => {
          ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
          for (let i = 0; i < 12; i++) {
            const p = (i * 30 + anim * 100) % 50 / 50;
            const q = 0.15 + p * 0.85;
            const w = 1 - p * p * p * p * p;
            ctx2.fillStyle = `rgba(${255 * w}, ${(50 + p * 200) * w}, ${30 * w}, ${(1 - p) * (1 - t * t * t)})`;
            ctx2.beginPath();
            ctx2.ellipse(
              (i * 83 % 130 - 65) * 0.5,
              -p * 56 + (i * 11 % 23 - 5) * 2,
              26 * (1 - p) * q,
              26 * (1 - p) / q * p,
              0,
              0,
              Math.PI * 2
            );
            ctx2.fill();
          }
        });
      } else if (powerType == 1) {
        retainTransform(() => {
          const p = 1 - t * t * t;
          ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
          ctx2.fillStyle = "#29e";
          ctx2.fillRect(-38 * p, -38 * p, 76 * p, 76 * p);
          ctx2.strokeStyle = "#eef";
          ctx2.lineWidth = 5 * p;
          ctx2.beginPath();
          ctx2.moveTo(-25, 5);
          ctx2.lineTo(-20, -5);
          ctx2.lineTo(-15, 5);
          ctx2.moveTo(-5, 25);
          ctx2.lineTo(0, 15);
          ctx2.lineTo(5, 25);
          ctx2.moveTo(-5, -15);
          ctx2.lineTo(0, -25);
          ctx2.lineTo(5, -15);
          ctx2.moveTo(25, 5);
          ctx2.lineTo(20, -5);
          ctx2.lineTo(15, 5);
          ctx2.stroke();
        });
      } else if (powerType == 2) {
        retainTransform(() => {
          ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
          ctx2.strokeStyle = "#131";
          ctx2.lineWidth = 11 * (1 - t);
          ctx2.beginPath();
          ctx2.moveTo(-18 * Math.cos(Math.round(anim * 13) * 123), -55);
          ctx2.lineTo(18 * Math.cos(Math.round(anim * 15) * 103), -40);
          ctx2.lineTo(-11 * Math.cos(Math.round(anim * 17) * 93), -20);
          ctx2.lineTo(11 * Math.cos(Math.round(anim * 13) * 133), -15);
          ctx2.lineTo(6 * Math.cos(Math.round(anim * 11) * 97), 10);
          ctx2.stroke();
          ctx2.strokeStyle = "#1f1";
          ctx2.lineWidth = 10 * (1 - t);
          ctx2.stroke();
        });
      }
    }
    return {
      update,
      render,
      order: renderOrder
    };
  }
  var ability_default = Ability;

  // src/runes.js
  var CARET_RUNE = [[-7, 10], [0, -10], [7, 10]];
  var CIRCLE_RUNE = [[10, 0], [9, 4], [7, 7], [4, 9], [0, 10], [-4, 9], [-7, 7], [-9, 4], [-10, 0], [-9, -4], [-7, -7], [-4, -9], [0, -10], [4, -9], [7, -7], [9, -4], [10, 0]];
  var BOLT_RUNE = [[-5, -10], [5, -10], [-3, 0], [3, 0], [0, 10]];
  var TRIANGLE_RUNE = [[-9, -10], [9, -10], [0, 10], [-9, -10]];
  var WAVE_RUNE = [[-10, -4], [-5, 4], [0, -4], [5, 4], [10, -4]];
  var HOURGLASS_RUNE = [[-9, -8], [9, 8], [9, -8], [-9, 8], [-9, -8]];
  var SQUARE_SHAPE = [[-7, -7], [7, -7], [7, -7], [7, 7], [7, 7], [-7, 7], [-7, 7], [-7, -7]];
  var PLUS_SHAPE = [[-7, 0], [7, 0], [0, -7], [0, 7]];
  var EX_SHAPE = [[-7, -7], [7, 7], [-7, 7], [7, -7]];
  var HORIZONTAL_SHAPE = [[-7, 0], [7, 0]];
  var VERTICAL_SHAPE = [[0, -7], [0, 7]];
  var COLOR_MAP = {
    0: [0.4, 0.4, 0.4],
    1: [1, 0.3, 0.3],
    2: [0.3, 0.65, 1],
    3: [0.4, 1, 0.4],
    4: [1, 1, 0.3],
    5: [1, 0.65, 0.3],
    6: [1, 0.4, 1]
  };

  // src/powerup.js
  var SHAPES = [
    SQUARE_SHAPE,
    PLUS_SHAPE,
    EX_SHAPE,
    HORIZONTAL_SHAPE,
    VERTICAL_SHAPE
  ];
  var POWER_COLORS2 = [
    [230, 30, 30],
    [48, 128, 230],
    [16, 240, 16]
  ];
  function PowerUp(cx, cy, powerType, shapeType) {
    let anim = 0;
    let remove2 = false;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80);
        const color = POWER_COLORS2[powerType];
        ctx2.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx2.beginPath();
        ctx2.ellipse(0, 0, 18 + Math.cos(anim * 12) * 1, 18 - Math.cos(anim * 12) * 1, 0, 0, Math.PI * 2);
        ctx2.fill();
        for (let i = 0; i < 3; i++) {
          const p = (i * 30 + anim * 50) % 50 / 50;
          const q = 0.15 + p * 0.85;
          ctx2.beginPath();
          ctx2.ellipse((i * 30 + 20) % 24 - 12, -p * 36, 12 * (1 - p) * q, 16 * (1 - p) / q * p, 0, 0, Math.PI * 2);
          ctx2.fill();
        }
        ctx2.strokeStyle = WHITE;
        ctx2.lineWidth = 5;
        ctx2.beginPath();
        const shape = SHAPES[shapeType];
        for (let i = 0; i < shape.length; i++) {
          const pt = shape[i];
          if (i % 2 == 0) {
            ctx2.moveTo(pt[0], pt[1]);
          } else {
            ctx2.lineTo(pt[0], pt[1]);
          }
        }
        ctx2.stroke();
      });
    }
    function update(dT) {
      anim += dT;
      return remove2;
    }
    function onRunestoneMove([cx0, cy0, cx1, cy1, bonkCoord]) {
      if (bonkCoord != null) {
        cx1 = bonkCoord[0];
        cy1 = bonkCoord[1];
      }
      let distToHit = -1;
      let totalDist = Math.abs(cy1 - cy0) + Math.abs(cx1 - cx0);
      if (cx0 == cx && cx1 == cx && (cy >= cy0 && cy <= cy1 || cy >= cy1 && cy <= cy0)) {
        distToHit = Math.abs(cy - cy0);
      }
      if (cy0 == cy && cy1 == cy && (cx >= cx0 && cx <= cx1 || cx >= cx1 && cx <= cx0)) {
        distToHit = Math.abs(cx - cx0);
      }
      if (distToHit >= 0) {
        setTimeout(() => {
          add(pulse_sfx_default(cx, cy, 60, POWER_COLORS2[powerType]));
          remove2 = true;
          emit(POWERUP_ACQUIRED);
          off(RUNESTONE_MOVE, onRunestoneMove);
        }, distToHit / (totalDist + 0.01) * 600);
        setTimeout(() => {
          applyAbility(cx1, cy1);
        }, 660);
      }
    }
    function castPattern(a) {
      const beats = {};
      for (let i = 0; i < a.length; i++) {
        const x = a[i][0];
        const y = a[i][1];
        if (x < 0 || x >= 6 || y < 0 || y >= 6) {
          continue;
        }
        setTimeout(() => {
          add(ability_default(x, y, powerType));
        }, a[i][2]);
        beats[a[i][2]] = true;
      }
      Object.keys(beats).map((t) => {
        setTimeout(() => emit(ABILITY_BEAT, powerType), t);
      });
    }
    function applyAbility(x, y) {
      if (shapeType == 0) {
        castPattern([
          [x - 1, y, 0],
          [x - 1, y - 1, 150],
          [x, y - 1, 0],
          [x + 1, y - 1, 150],
          [x + 1, y, 0],
          [x + 1, y + 1, 150],
          [x, y + 1, 0],
          [x - 1, y + 1, 150]
        ]);
      } else if (shapeType == 1) {
        castPattern([
          [x - 1, y, 0],
          [x, y - 1, 0],
          [x + 1, y, 0],
          [x, y + 1, 0],
          [x - 2, y, 300],
          [x, y - 2, 300],
          [x + 2, y, 300],
          [x, y + 2, 300]
        ]);
      } else if (shapeType == 2) {
        castPattern([
          [x - 1, y - 1, 0],
          [x + 1, y - 1, 0],
          [x - 1, y + 1, 0],
          [x + 1, y + 1, 0],
          [x - 2, y - 2, 300],
          [x + 2, y - 2, 300],
          [x - 2, y + 2, 300],
          [x + 2, y + 2, 300]
        ]);
      } else if (shapeType == 3) {
        castPattern([
          [x - 1, y, 0],
          [x - 2, y, 100],
          [x - 3, y, 200],
          [x - 4, y, 300],
          [x - 5, y, 400],
          [x + 1, y, 0],
          [x + 2, y, 100],
          [x + 3, y, 200],
          [x + 4, y, 300],
          [x + 5, y, 400]
        ]);
      } else if (shapeType == 4) {
        castPattern([
          [x, y - 1, 0],
          [x, y - 2, 100],
          [x, y - 3, 200],
          [x, y - 4, 300],
          [x, y - 5, 400],
          [x, y + 1, 0],
          [x, y + 2, 100],
          [x, y + 3, 200],
          [x, y + 4, 300],
          [x, y + 5, 400]
        ]);
      }
    }
    on(RUNESTONE_MOVE, onRunestoneMove);
    return {
      render,
      update,
      tags: ["obstacle"],
      order: 15,
      getX: () => cx,
      getY: () => cy
    };
  }
  var powerup_default = PowerUp;

  // src/rune-stone.js
  var ORDER_REMAP = { 5: 0, 1: 1, 3: 2, 2: 3, 4: 4, 6: 5 };
  var runeOrder = [
    CARET_RUNE,
    CIRCLE_RUNE,
    BOLT_RUNE,
    TRIANGLE_RUNE,
    WAVE_RUNE,
    HOURGLASS_RUNE
  ];
  var OUTLINE_COLOR = "#828";
  var FILL_COLOR = "#f7f";
  var DOT_COLOR = "#fff";
  function RuneStone() {
    let anim = 0;
    let gameOver = false;
    let cx = 0;
    let cy = 2;
    const mesh = [[-35, 0], [-15, 30], [15, 30], [35, 0], [15, -30], [-15, -30]];
    const MOVE_DURATION = 0.66;
    const IDLE = 0;
    const MOVING = 1;
    let state = IDLE;
    let timeInState = 0;
    let targetCX = 0;
    let targetCY = 0;
    let bonkCX = -1;
    let bonkCY = -1;
    let originCX = 0;
    let originCY = 0;
    let self = {};
    function render(ctx2) {
      const caster = getObjectsByTag("caster")[0];
      retainTransform(() => {
        for (let i = 0; i < 6; i++) {
          ctx2.lineWidth = 4;
          const SIZE = 80;
          const highlight = caster.getIsDrawing() || caster.getInDrawArea();
          if (highlight && caster.getDrawingOnLeft()) {
            ctx2.strokeStyle = WHITE;
          } else {
            ctx2.strokeStyle = "#fbcda1";
          }
          retainTransform(() => {
            ctx2.translate(-SIZE / 2, SIZE / 2 + SIZE * i);
            ctx2.scale(1.5, 1.5);
            renderLines(ctx2, runeOrder[i]);
          });
          if (highlight && !caster.getDrawingOnLeft()) {
            ctx2.strokeStyle = WHITE;
          } else {
            ctx2.strokeStyle = "#fbcda1";
          }
          retainTransform(() => {
            ctx2.translate(SIZE / 2 + SIZE * i, SIZE * 6.5);
            ctx2.scale(1.5, 1.5);
            renderLines(ctx2, runeOrder[i]);
          });
        }
        ctx2.translate((cx + 0.5) * 80, (cy + 0.5) * 80 + 4);
        ctx2.fillStyle = "rgba(0,0,0,0.13)";
        ctx2.beginPath();
        ctx2.ellipse(0, 0, 32, 22, 0, 0, 2 * Math.PI);
        ctx2.fill();
        if (state == MOVING) {
          const p = timeInState / MOVE_DURATION;
          ctx2.translate(0, -90 * p * (1 - p));
        }
        const angle = anim;
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const xfmMesh = mesh.map((pt) => {
          return [
            (pt[0] * c + pt[1] * s) * 0.8,
            (-pt[0] * s * 0.6 + pt[1] * c * 0.6) * 0.8
          ];
        });
        ctx2.lineWidth = 10;
        ctx2.strokeStyle = OUTLINE_COLOR;
        ctx2.fillStyle = FILL_COLOR;
        renderAndFill(ctx2, xfmMesh);
        ctx2.translate(0, -11);
        ctx2.lineWidth = 6;
        ctx2.beginPath();
        for (let i = 0; i < 6; i++) {
          const pt = mesh[i];
          const x = (pt[0] * c + pt[1] * s) * 0.83;
          const y = (-pt[0] * s * 0.6 + pt[1] * c * 0.6) * 0.83;
          ctx2.moveTo(x, y);
          ctx2.lineTo(x, y + 10);
        }
        ctx2.stroke();
        ctx2.lineWidth = 10;
        ctx2.fillStyle = FILL_COLOR;
        renderAndFill(ctx2, xfmMesh);
        ctx2.strokeStyle = DOT_COLOR;
        ctx2.beginPath();
        ctx2.lineWidth = 6;
        const DOTS = [[0, -7], [7, 6], [-7, 6]];
        for (let i = 0; i < 3; i++) {
          const pt = DOTS[i];
          const x = (pt[0] * c + pt[1] * s) * 1;
          const y = (-pt[0] * s * 0.6 + pt[1] * c * 0.6) * 1;
          ctx2.moveTo(x, y);
          ctx2.lineTo(x + 0.01, y);
        }
        ctx2.stroke();
      });
    }
    function update(dT) {
      timeInState += dT;
      if (state == MOVING) {
        const p = timeInState / MOVE_DURATION;
        anim = p * Math.PI * 2;
        cx = originCX * (1 - p) + targetCX * p;
        cy = originCY * (1 - p) + targetCY * p;
        if (bonkCX > 0 || bonkCY > 0) {
          const distSplit = Math.abs(originCX - targetCX) + Math.abs(originCY - targetCY);
          const percentSplit = distSplit / (distSplit + 0.5);
          if (p > percentSplit) {
            const q = (p - percentSplit) / (1 - percentSplit);
            cx = cx * (1 - q) + bonkCX * q;
            cy = cy * (1 - q) + bonkCY * q;
          }
        }
        if (p >= 1) {
          if (bonkCX > 0 || bonkCY > 0) {
            cx = bonkCX;
            cy = bonkCY;
          } else {
            cx = targetCX;
            cy = targetCY;
          }
          timeInState = IDLE;
          state = IDLE;
          anim = 0;
          targetCX = cx;
          targetCY = cy;
          emit(RUNESTONE_LAND);
          add(pulse_sfx_default(cx, cy, 50, [255, 255, 255]));
          setTimeout(() => {
            emit(TURN_END);
          }, 550);
        }
        self.order = 30 + cy * 0.02;
        resort();
      }
    }
    function moveToDest(x, y, hitCoord) {
      originCX = cx;
      originCY = cy;
      targetCX = x;
      targetCY = y;
      state = MOVING;
      timeInState = 0;
      if (hitCoord != null) {
        targetCX = hitCoord[0];
        targetCY = hitCoord[1];
        bonkCX = x;
        bonkCY = y;
        const distSplit = Math.abs(originCX - targetCX) + Math.abs(originCY - targetCY);
        const percentSplit = distSplit / (distSplit + 0.5);
        setTimeout(() => {
          emit(ENEMY_BONK);
          add(pulse_sfx_default(targetCX, targetCY, 50, [255, 0, 255]));
        }, MOVE_DURATION * 1e3 * percentSplit);
      } else {
        bonkCX = -1;
        bonkCY = -1;
      }
      emit(RUNESTONE_MOVE, [originCX, originCY, targetCX, targetCY, hitCoord != null ? [bonkCX, bonkCY] : null]);
    }
    function onSigilDrawn([idx, axis]) {
      if (gameOver) {
        return;
      }
      if (idx == 0) {
        return;
      }
      const m = ORDER_REMAP[idx];
      if (axis == 1) {
        const dir = Math.sign(m - cx);
        let destX = cx;
        let hitX = -1;
        for (let tx = cx + dir; dir > 0 && tx <= m || dir < 0 && tx >= m; tx += dir) {
          if (spotHasEnemy(tx, cy)) {
            hitX = tx;
            break;
          }
          destX = tx;
        }
        if (hitX >= 0) {
          moveToDest(destX, cy, [hitX, cy]);
        } else {
          moveToDest(destX, cy, null);
        }
      } else {
        const dir = Math.sign(m - cy);
        let destY = cy;
        let hitY = -1;
        for (let ty = cy + dir; dir > 0 && ty <= m || dir < 0 && ty >= m; ty += dir) {
          if (spotHasEnemy(cx, ty)) {
            hitY = ty;
            break;
          }
          destY = ty;
        }
        if (hitY >= 0) {
          moveToDest(cx, destY, [cx, hitY]);
        } else {
          moveToDest(cx, destY, null);
        }
      }
    }
    function onGG() {
      gameOver = true;
    }
    on(SIGIL_DRAWN, onSigilDrawn);
    on(GAME_OVER, onGG);
    self = {
      update,
      render,
      order: 30 + cy * 0.02,
      tags: ["obstacle"],
      getX: () => targetCX,
      getY: () => targetCY
    };
    return self;
  }
  var rune_stone_default = RuneStone;

  // ../rune-classifier/base64_encoded_model.txt
  var base64_encoded_model_default = "eJiYiIiJeIiIiXeIiIiXmXl3iXh5iIiHh3eJmXiIl5l3iHd4iIiIh3d4eZeIiIiHiIeJiXeJiIh4mJl3iHl5h5iHiYiIeIeYiIiYmIh3d4iHmIeIh5iJmYmXiIeXh3l4h3mYeXh5iXiIiJeIeJiXd3iYmXeJmId5h4mXd5eJiHiIiJmXeHl5iJiIh4eIiXiXiHiIiId3iIiIl5iIh3mYiYiIiIeHiHmId4h4l3d3d4iIiImJeIiIh4iHiIiYiXiJl5mIiIiJiYiYeHiIiZh4iZd3l5iYd4iIiHiJmZeXmJh4iImZiHh4iZiHiIiZmYd4eIiJh4h4eJh4h3d3eHiJh5d5d4d3iXeIeIiIeImIiYiHl5iIeYh5d4d4iHeIiXeIiHiIh3iHmJiIiIiIiJl4iIeIiIiIiYiImJiYiHh3h3eImZmXh5iIh6iYl3iJiXeIl5h3eZmIeIh4eId3iJl4h4iZeYiJh4iImXiYeHiZeIiJeXeIl5l4mYmYiIiIeIeIiIeHiXh3d4eId4mHmYl4iJiYh5iHeIiYmYiZiHiIiIiIiXmIiYd4h5iHh4h3d4iHiHiIh4h4h3d4iHmIiIiIiJiIh4h5iIeYmZiJiIiXiJmYeJiYiIiHiImHiImYiIl4eHeZiImJeHiImJiYh5h3mHmXeIh4d5h4eJmJiHh4h3iIeId3iYiHh5eXmYmIeImIeJeIh4d4h5mHd5iIiYiJd5eId3iHiIiHl4mIh4eYeIiZmYiHh5mHiJmIl4mId3iHd4iJh4d5l4d3eIh4iIiXiIiIiImIiHmImIh4iHeJiJmJiHiHeId4mHmJiHh4eIiId4l5mIiJiHiJiYiImXd3eIiIiYmIiYmYh4mImImIh3iId4d4d5eYd4iIl5iJh5eHd4eIeYeJl4iYmImJiXeHmYmIiIh4l4l4mJeHiIiId4mXmXeHmHmIiJmYmIiJiYl5iXiHh3eYiId4eIiIh4h4h3h4eIeHeId3h4iHiHh3iHiImImImImZiYiHmJiJiHiIiImId5d3mZeIh5h5h4iHiIiHeJiIiYl4mHiZiZiIiXmIl4mZh4mJiYh4iJiHiYh4iIeYl5eJiIiImImIiYeYiYiIiIeHeIl4h5iFeIiHeId4h4eIiIiIiIiIiImIeIiIeIiIiIiIiJiIiIiIiYiIiIiYeIiIiIiIiImIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiHeIiIeIiHiYeIiIiIiIiIh4h4iJiIiIiIeHiIiIiJiIiIiHiJiIh3iIh3iHiHiIiIeIiIeIiIiIh4iHiJiHeIiIh3eIh4iIh4h3iYiIiIiHiIiIiIiIeIiIeIiIiIiIiIiIiIiIeId4d4eYh3mHh4iHiIh4iIeYiJiIiIeIiYeHiIiHiIiIiIiIeHiJiIeIiIh4eIiHiHiHiIiZiImHmJiIh4iIiIiIh4iIiIiIiIiIeIiIiIiIiHh4mIiJiIiIiIiIiIiJmIiIiIiId4iHiIiIiIiIiJiIiHiIiIh4h4iIiImIiIiIiIh4iImIiIeIiIiIiIiIiIiIiHiIiIh4mIiIiImIiIiIeIh4h4iIh3iIiHmJiHiIiIiHiIh4h4iIiImIiImIiIiIiImIh4iYiJh4iIiImIh4iIiIeIh3iIiIiIiIh4iImIiIiYeIiIeHiIiYeIiIiIiId4iIiIiIiJiIeIiIiYiIiIiIeHiIiJiIeIeHiIh4iIiHiIiIiIiIiIh4iIiHiIiIeIiIiIiIh4eIiHh4iIeHh4h3iJiIiIiIiXd4iIiIeImIiIiIiJiIiIiIiImIiIiIiIiHh4iIiIh4iIiIiYeImImIiIh4eIiJiIiIiJeIiIiIiIiIiIiHiHeIiIiIiIiIiIiIh4iIiYh4h4h4iIiHiIeHeHiIiJiIh3iHmJiIh4iIiIeIh4iHmZmIiYiYh4iIiIiIeImHiIiIiHiImYeIiImIeIh3iHd3mIiIiHiHiImIiIiIiIeIeHeYiIl4iIiHh4iHh4h4iIiIiIiHiHiIeHeYh4iIeIiIiImImIiIiIh4eIiIiYiIiIiIiIiIiIeIiIiIiIiIiIiIiId4iIiJiIiIiIiIiIh4iYiIiIiIiIiIh4iIiJeIiIiIiIiIiIiYiYiJiJiXiIiIiIiIh4iHd5iIiZh5iJiYiIiIiIiIiIiIiHd4iHiIiIiIeJiIiIiIh3iImIiIiIiIiIiIiIiIiIiIh4l4iIiIiIiIiIeJiIiIiJeIiIiIiIiHiIl4eImIiIiIiIiYh3iIiIiIiIiImYeIiIiJiIiIiIiIiIiIiIiIiIeIiId4iYiIiIiIh4iHiIiIiIiImIiIiHiJiImIeIiIiIeImHiIiHiIiIiIiJd5iIiIiIiHiIiIiIiIiIiIiIiIiYiIiIiIiIiIiJiIiYeIiIiIiIiIeImIiIiIiHiIh4iIiIiJmIiIh3iIiIh4iIeIh4iIiIiIeIiIiIiIiIiIiIiIeIh4mIiHeIiYiJh4iIiHiIiIiIiIiHiIiYiIiIiIeIeZh4eHeIiIeIiJh4iIiHiIiIiIiIiIiHiIh3mIiHh4iIh4iJd4iHmIeIiHeIh4iYiIiIiIiImIh4iYiImIiIiJh4h4h4mIeIiHiIh4iIiHiIiIiJh4iIiIiIiYiYd5iIiHiHh4iHiIiIiHiIh4h3h4iIeYh4iIh4iIiHeIiIiIiIiIeIiJh4iIiHiJiIiIiIiIiIiImIeIiIiIiIiIiJiIiIiImIiIiIiIiImIiIiIiIh4iIiIeIiIiIiIh4iIiIh4iIiIiIiIiIiHh4h4iIiIiIiIiIiIeIiIiIiIiIh4iIiIiIiIiIiIiYiIh4eYiHiIiIiIiHiImIiJh4iIiIeJiHiHiIeHiIiIiHiIh4eIh4iHiId3iImHiIiId4iIiJiIeIeIeIiIiIiIiIiIiIiIiIiHiHh4eIiIh4mIiYiIiIiIiImHiIeIiIiHiIiIiJiIeIiIh4eIeIiIeIiHiIiHiIh4iIh4iIiIiXiJiIiImIiHiHiIiIiIh4iJiIiIiHiYiYmIiIiIh4iIiIeIiJiJiIiIiXiIh4h4iHiIh4mXh5iIeIiIiIiHiIiIiIiIeIiIiImIiIiIiIiIiIh4h3iHiHd4iYd4iJiImIiImIiJiIiIiIiIiIiIeJiImHiIiIeHh5iIiIiIiIiIiJiImYmImIl4iImIiJiJiIiIiIiHiJh4iIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIh4iIiIh4h4iHiIiGiIiIiIiIiIiIiIiJiIh4iIiIiIiIh4eIiHeIeIh4h4iJh3h3h4eJiIiIiIh4iIeIiIiIiHiIeImIiIiIiIiIiImYiIeIiIh4iYiIiIiIiHiIeIiIiIiIiIiIiIiXiIiIiIiIeIiIiIh4h3iIiHiYmJiIeIeIiHh2qXmYd4mJmImKd4l4mYmHiWmIl4iHiIe5mIhpmJl4eaiaqZd6aJeZqXh3iYiXaYiHqIqJiZVnenmHaJd3qXd2eZh5mJeYmHZWmXeHiGiZlpmZhomYmml2eJiHtnZ5l4mZiZiIdolpmphnmWd4mKmIhXd5aIh5h5Z6aIiZZqmYh5h3ipandpqXeGqHiZaXdnmYh5l5l4d4qZiXmpipiGeIaIlaeIiZqHmXl5imeYaHiZmHl3eIh3iVipl5aWephnh2eYh4iWiWiHiJeJeHiHh7pZiXiHZ4qWl5aZqZmIhnhoeXmIiWd4eaibaJl3l3Zpl3alh5maiIZ5aGeZh4l4iZiXl3l2eJeYh5h5iJmYmZhmeHhpiKeZlneWead6iXt6eKmXd5mniWeGlnmYiWipeYeFmYZ4eHmXmlaqh2iIiJlplpiJiIl4qYmIdoepiIl4mYp4iYeImIqZaaaIiZh5d3Z4";

  // src/rune-model.js
  var encodedWeights = atob(base64_encoded_model_default);
  var modelParams = [];
  for (let i = 0; i < 0 + 1 * encodedWeights.length; i++) {
    const a = encodedWeights.charCodeAt(i);
    modelParams.push(((a & 15) - 8) * 2.2 / 16, ((a >> 4 & 15) - 8) * 2.2 / 16);
  }
  function linearReluLayer(data, modelParams2, numOutputs, numInputs, x0, y0, span, stride, weightOffset, biasOffset) {
    const outputs = new Array(numOutputs);
    for (let i = 0; i < numOutputs; i++) {
      let acc = 0;
      for (let j = 0; j < numInputs; j++) {
        const inputIndex = y0 + j % span + stride * (x0 + Math.floor(j / span));
        const weightIndex = weightOffset + i * numInputs + j;
        acc += modelParams2[weightIndex] * data[inputIndex];
      }
      const biasIndex = i + biasOffset + weightOffset;
      outputs[i] = Math.max(0, modelParams2[biasIndex] + acc);
    }
    return outputs;
  }
  function layerNorm(t) {
    const mean = t.reduce((acc, val) => acc + val, 0) / t.length;
    const variance = t.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / t.length;
    return t.map((val) => (val - mean) / Math.sqrt(variance + 1e-3));
  }
  function classify(data) {
    const BASE_PATCH = 7 * 7;
    const PATCH_FEATURES = 34;
    const PATCH_FEATURES_DEEP = 25;
    const NUM_CLASSES = 7;
    x11 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x12 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x13 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x14 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 0, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x21 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x22 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x23 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x24 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 7, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x31 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x32 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x33 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x34 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 14, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x41 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 0, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x42 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 7, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x43 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 14, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    x44 = layerNorm(linearReluLayer(data, modelParams, PATCH_FEATURES, BASE_PATCH, 21, 21, 7, 28, 0, BASE_PATCH * PATCH_FEATURES));
    y11 = layerNorm(linearReluLayer(
      x11.concat(x12, x21, x22),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y12 = layerNorm(linearReluLayer(
      x13.concat(x14, x23, x24),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y21 = layerNorm(linearReluLayer(
      x31.concat(x32, x41, x42),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    y22 = layerNorm(linearReluLayer(
      x33.concat(x34, x43, x44),
      modelParams,
      PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES,
      4 * PATCH_FEATURES * PATCH_FEATURES_DEEP
    ));
    z = linearReluLayer(
      y11.concat(y12, y21, y22),
      modelParams,
      NUM_CLASSES,
      4 * PATCH_FEATURES_DEEP,
      0,
      0,
      1e3,
      0,
      BASE_PATCH * PATCH_FEATURES + PATCH_FEATURES + 4 * PATCH_FEATURES * PATCH_FEATURES_DEEP + PATCH_FEATURES_DEEP,
      4 * PATCH_FEATURES_DEEP * NUM_CLASSES
    );
    return z;
  }

  // src/spell-caster.js
  function SpellCaster() {
    const scaledCanvas = document.createElement("canvas");
    const scaledCtx = scaledCanvas.getContext("2d");
    const grayscaleArray = new Array(28 * 28);
    const mapping = {
      0: "garbage",
      1: "circle",
      2: "triangle",
      3: "bolt",
      4: "wave",
      5: "caret",
      6: "hourglass"
    };
    const lines = [];
    let isDrawing = false;
    let selectedLines = [];
    let selectedClass = -1;
    let timeSinceSelect = 0;
    let drawingOnLeft = false;
    let inDrawArea = false;
    function touchifyEvent(evt) {
      const touches = evt.changedTouches;
      if (touches) {
        evt.clientX = touches[0].clientX;
        evt.clientY = touches[0].clientY;
      }
    }
    function onMouseDown(evt) {
      touchifyEvent(evt);
      selectedClass = -1;
      if (evt.clientY < canvas.height * 0.65 - 5) {
        return;
      }
      drawingOnLeft = evt.clientX < canvas.width / 2;
      lines.length = 0;
      lines.push([evt.clientX, evt.clientY]);
      isDrawing = true;
    }
    function onMouseMove(evt) {
      touchifyEvent(evt);
      if (!isDrawing) {
        drawingOnLeft = evt.clientX < canvas.width / 2;
      }
      inDrawArea = evt.clientY > canvas.height * 0.65 - 5;
      if (isDrawing && lines.length > 0) {
        const latestPt = lines[lines.length - 1];
        let dx = evt.clientX - latestPt[0];
        let dy = evt.clientY - latestPt[1];
        if (!inDrawArea) {
          return;
        }
        if (drawingOnLeft && evt.clientX > canvas.width / 2) {
          return;
        }
        if (!drawingOnLeft && evt.clientX < canvas.width / 2) {
          return;
        }
        if (dx * dx + dy * dy > 20) {
          lines.push([evt.clientX, evt.clientY]);
        }
      }
    }
    function onMouseUp(evt) {
      touchifyEvent(evt);
      if (lines.length == 0) {
        return;
      }
      selectedClass = classifyDrawing();
      selectedLines = JSON.parse(JSON.stringify(lines));
      timeSinceSelect = 0;
      lines.length = 0;
      isDrawing = false;
      emit(SIGIL_DRAWN, [selectedClass, drawingOnLeft ? 0 : 1]);
    }
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("touchstart", onMouseDown);
    window.addEventListener("touchmove", onMouseMove);
    window.addEventListener("touchend", onMouseUp);
    function classifyDrawing() {
      let mins = [Infinity, Infinity];
      let maxs = [-Infinity, -Infinity];
      lines.map((pt) => {
        mins[0] = Math.min(pt[0], mins[0]);
        mins[1] = Math.min(pt[1], mins[1]);
        maxs[0] = Math.max(pt[0], maxs[0]);
        maxs[1] = Math.max(pt[1], maxs[1]);
      });
      let normalizeLines = [];
      let size = Math.max(maxs[0] - mins[0], maxs[1] - mins[1]);
      if (size < 70) {
        return 0;
      }
      size = Math.max(size, 100);
      const tracker = {};
      let topPred = 0;
      let topVal = 0;
      for (let i = 0; i < 20; i++) {
        normalizeLines = [];
        const SKX = Math.random() * 3 + 16;
        const SKY = Math.random() * 3 + 16;
        lines.map((pt) => {
          normalizeLines.push([
            (pt[0] - (maxs[0] + mins[0]) / 2) / size * SKX,
            (pt[1] - (maxs[1] + mins[1]) / 2) / size * SKY
          ]);
        });
        scaledCtx.setTransform(1, 0, 0, 1, 0, 0);
        scaledCtx.clearRect(0, 0, 28, 28);
        scaledCtx.strokeStyle = "white";
        scaledCtx.lineWidth = Math.random() * 0.5 + 1.3;
        scaledCtx.lineJoin = "round";
        scaledCtx.lineCap = "round";
        scaledCtx.setTransform(
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          1 + (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 2 + 14,
          (Math.random() - 0.5) * 2 + 14
        );
        renderLines(scaledCtx, normalizeLines);
        const scaledImage = scaledCtx.getImageData(0, 0, 28, 28);
        const pixelData = scaledImage.data;
        for (let i2 = 0; i2 < pixelData.length; i2 += 4) {
          grayscaleArray[i2 >> 2] = pixelData[i2] / 255;
        }
        const z2 = classify(grayscaleArray);
        const argmax = (arr) => arr.reduce((iMax, x, i2, arr2) => x > arr2[iMax] ? i2 : iMax, 0);
        const prediction = argmax(z2);
        if (tracker[prediction] === void 0) {
          tracker[prediction] = 0;
        }
        tracker[prediction] += 1;
        const v = tracker[prediction];
        if (v > topVal) {
          topVal = v;
          topPred = prediction;
        }
      }
      return topPred;
    }
    function render(ctx2) {
      retainTransform(() => {
        ctx2.setTransform(1, 0, 0, 1, 0, 0);
        ctx2.fillStyle = DARK_GRAY;
        ctx2.fillRect(0, canvas.height * 0.65, canvas.width, canvas.height * 0.36);
        ctx2.lineWidth = 10;
        ctx2.strokeStyle = "#3d3d3d";
        renderLines(ctx2, [[canvas.width / 2, canvas.height * 0.65], [canvas.width / 2, canvas.height]]);
        ctx2.strokeStyle = BLACK;
        renderLines(ctx2, [[0, canvas.height * 0.65], [canvas.width, canvas.height * 0.65]]);
        ctx2.lineWidth = 6;
        let h = canvas.height * 0.65 + 30;
        let w = canvas.width / 2 - 10;
        ctx2.strokeStyle = "#664";
        renderLines(ctx2, [[w - 30, h], [w - 30, h + 40]]);
        renderLines(ctx2, [[w - 40, h + 10], [w - 30, h], [w - 20, h + 10]]);
        renderLines(ctx2, [[w - 40, h + 30], [w - 30, h + 40], [w - 20, h + 30]]);
        ctx2.strokeStyle = "#466";
        h += 20;
        w = canvas.width / 2;
        renderLines(ctx2, [[w + 30, h], [w + 70, h]]);
        renderLines(ctx2, [[w + 40, h - 10], [w + 30, h], [w + 40, h + 10]]);
        renderLines(ctx2, [[w + 60, h - 10], [w + 70, h], [w + 60, h + 10]]);
        if (isDrawing) {
          ctx2.strokeStyle = "white";
          ctx2.lineWidth = 20;
          renderLines(ctx2, lines);
        }
        if (selectedClass != -1) {
          const p = Math.exp(-timeSinceSelect * 3) * 2;
          const c = COLOR_MAP[selectedClass];
          ctx2.strokeStyle = `rgba(${c[0] * 255}, ${c[1] * 255}, ${c[2] * 255}, ${p * 0.6})`;
          ctx2.lineWidth = 20 + (1 - Math.exp(-timeSinceSelect * 5)) * 80;
          renderLines(ctx2, selectedLines);
          ctx2.strokeStyle = `rgba(${c[0] * 300}, ${c[1] * 300}, ${c[2] * 300}, ${p})`;
          ctx2.lineWidth = 20;
          renderLines(ctx2, selectedLines);
        }
      });
    }
    function update(dT) {
      timeSinceSelect += dT;
      if (selectedClass != -1 && timeSinceSelect < 5) {
        selectedLines.map((pt, i) => {
          pt[0] += Math.cos(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
          pt[1] += Math.sin(timeSinceSelect * 3 + 0.2 * i) * 24 * dT;
        });
      }
    }
    return {
      update,
      render,
      tags: ["caster"],
      getIsDrawing: () => isDrawing,
      getDrawingOnLeft: () => drawingOnLeft,
      getInDrawArea: () => inDrawArea
    };
  }
  var spell_caster_default = SpellCaster;

  // src/wizard.js
  function Wizard() {
    let anim = 0;
    let hp = 10;
    let dead = false;
    function render(ctx2) {
      retainTransform(() => {
        ctx2.translate(-120, 160);
        if (hp > 0) {
          ctx2.fillStyle = "#f11";
          ctx2.textAlign = "center";
          ctx2.font = `bold 30px arial`;
          ctx2.fillText(`${hp} HP`, 0, 230);
        }
        ctx2.fillStyle = GRAY;
        ctx2.strokeStyle = DARK_GRAY;
        ctx2.lineWidth = 10;
        for (let i = 0; i < 4; i++) {
          ctx2.translate(0, 20);
          renderAndFill(ctx2, [[-30, 0], [-15, 10], [-15, 30], [-30, 20]]);
          renderAndFill(ctx2, [[-15, 10], [15, 10], [30, 0], [30, 20], [15, 30], [-15, 30]]);
          ctx2.translate(0, 20);
          renderAndFill(ctx2, [[-30, 0], [-15, 10], [15, 10], [15, 30], [-15, 30], [-30, 20]]);
          renderAndFill(ctx2, [[15, 10], [30, 0], [30, 20], [15, 30]]);
        }
        ctx2.translate(0, -143);
        ctx2.fillStyle = MID_GRAY;
        renderAndFill(ctx2, [[-30, 0], [-15, 10], [15, 10], [30, 0], [15, -10], [-15, -10]]);
        if (hp > 0) {
          ctx2.translate(3, -2);
          ctx2.fillStyle = BLACK;
          ctx2.strokeStyle = BLACK;
          ctx2.lineWidth = 4;
          const squeeze = -Math.cos(anim * 10) * 0.05 + 0.95;
          renderAndFill(ctx2, [[-20 * squeeze, 0], [12 * squeeze, 0], [1 * squeeze, -30], [-10 * squeeze, -10]]);
          ctx2.fillStyle = PURPLE;
          ctx2.strokeStyle = PURPLE;
          ctx2.translate(0, -23 + Math.abs(Math.sin(anim * 5) * 2.5));
          ctx2.rotate(Math.sin(anim * 10 + 3) * 0.08);
          renderAndFill(ctx2, [[-20, 2], [-10, -1], [13, 0], [20, 4], [17, 0], [12, -5], [7, -13], [0, -23], [-10, -29], [-21, -20], [-12, -22], [-6, -10]]);
          ctx2.lineWidth = 7;
          ctx2.strokeStyle = WHITE;
          renderLines(ctx2, [[8, -4], [8.01, -4]]);
          renderLines(ctx2, [[-1, -4], [-1.01, -4]]);
          renderLines(ctx2, [[2, -11], [2.01, -11]]);
        }
      });
    }
    function update(dT) {
      anim += dT * 1.52;
    }
    function onEnemyDamage(dmg) {
      hp -= dmg;
      if (hp <= 0) {
        hp = 0;
        if (!dead) {
          dead = true;
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              add(pulse_sfx_default(-2, 1.5, 70, [255, 255, 255]));
            }, i * 400);
          }
          emit(GAME_OVER);
        }
      }
    }
    on(ENEMY_DAMAGE, onEnemyDamage);
    return {
      update,
      render
    };
  }
  var wizard_default = Wizard;

  // src/audio.js
  function clamp(v, a, b) {
    return Math.min(Math.max(v, a), b);
  }
  function Audio() {
    audioCtx = new AudioContext();
    sampleRate = audioCtx.sampleRate;
    let attackHitSound;
    let runestoneLandedSound;
    let runestoneMoveSound;
    let powerupCollectSound;
    let enemyMoveSound;
    let enemySwordSound;
    let fireSound;
    let iceSound;
    let zapSound;
    let sigilCaret;
    let sigilCircle;
    let sigilBolt;
    let sigilTriangle;
    let sigilWave;
    let sigilHourglass;
    let sigilGarbage;
    let musicBuffer;
    let activeMusicSource;
    let gainNodeA;
    let gainNodeB;
    let usingA = true;
    const sin = (i) => Math.sin(i);
    const saw = (i) => (i % 6.28 - 3.14) / 6.28;
    const sqr = (i) => clamp(Math.sin(i) * 1e3, -1, 1);
    async function _yield() {
      return new Promise((r) => setTimeout(r, 0));
    }
    function setProgress(p) {
      emit("load-progress", p);
    }
    async function generate(duration, fn) {
      let audioBuffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
      let buffer = audioBuffer.getChannelData(0);
      let N = audioBuffer.length;
      for (let i = 0; i < N; i++) {
        buffer[i] = fn(i * 44100 / sampleRate) * (1 - i / N);
      }
      await _yield();
      return audioBuffer;
    }
    async function init() {
      attackSound = await generate(0.2, (i) => {
        return 0.05 * saw(i / (0.3 - 220 * Math.exp(-i / 500)));
      });
      attackHitSound = await generate(0.2, (i) => {
        return 0.15 * (sin(i / (20 + i / 150)) * 0.3 + Math.random());
      });
      enemySwordSound = await generate(0.2, (i) => {
        return 0.07 * saw(i / (0.3 - 220 * Math.exp(-i / 500)));
      });
      runestoneLandedSound = await generate(0.25, (i) => {
        return 0.1 * (sqr(i / (120 + i / 250)) * 0.3 + Math.random()) * (sqr(i / 600) * 0.5 + 0.5);
      });
      runestoneMoveSound = await generate(0.1, (i) => {
        return 0.1 * sqr(i / (20 + 150 * Math.exp(-i / 1600)));
      });
      enemyMoveSound = await generate(0.3, (i) => {
        return 0.06 * (sin(i / (14 + i * i / 1e6)) + Math.random() / 2);
      });
      powerupCollectSound = await generate(0.3, (i) => {
        return 0.08 * sin(i / (100 - i / 20));
      });
      fireSound = await generate(0.4, (i) => {
        return 0.16 * Math.random();
      });
      iceSound = await generate(0.4, (i) => {
        return 0.11 * (sqr(i / (30 + i / 500)) * (sqr(i / (1500 + i / 60)) * 0.5 + 0.5) * (sqr(i / (600 + i / 40)) * 0.5 + 0.5));
      });
      zapSound = await generate(0.5, (i) => {
        return 0.15 * (saw(i / (3 + i / 250)) + Math.random() * 0.1);
      });
      function sigilNote(i, pitch, time) {
        const q = Math.pow(2, -pitch / 12) * 18;
        return 0.1 * (saw(i / q) * sin(i / (q * 2 + 3 * sin(i / 2e5)))) * (i / 44100 - time > 0 ? 1 : 0) * Math.exp(-(i / 44100 - time) * 7);
      }
      sigilCaret = await generate(2, (i) => {
        return sigilNote(i, 0, 0) + sigilNote(i, 7, 0.15) + sigilNote(i, 0, 0.3);
      });
      sigilCircle = await generate(2, (i) => {
        return sigilNote(i, 2, 0) + sigilNote(i, 3, 0.15) + sigilNote(i, 5, 0.3);
      });
      sigilBolt = await generate(2, (i) => {
        return sigilNote(i, 12, 0) + sigilNote(i, 6, 0.15) + sigilNote(i, 0, 0.3);
      });
      sigilTriangle = await generate(2, (i) => {
        return sigilNote(i, 10, 0) + sigilNote(i, 10, 0.15) + sigilNote(i, 3, 0.3);
      });
      sigilWave = await generate(2, (i) => {
        return sigilNote(i, 5, 0) + sigilNote(i, 4, 0.15) + sigilNote(i, 5, 0.3);
      });
      sigilHourglass = await generate(2, (i) => {
        return sigilNote(i, 8, 0) + sigilNote(i, 1, 0.15) + sigilNote(i, 4, 0.3);
      });
      sigilGarbage = await generate(2, (i) => {
        return sigilNote(i, -4, 0) + sigilNote(i, -10, 0.15) + sigilNote(i, -4, 0.3);
      });
      const pace = sampleRate * 0.82;
      const drumMusicBuffer = audioCtx.createBuffer(1, pace, sampleRate);
      const drumBuffer2 = drumMusicBuffer.getChannelData(0);
      const W = 0.1 * sampleRate;
      for (let j = 0; j < W; j++) {
        drumBuffer2[j] += 0.06 * (sin(j / (70 + j / 300)) + Math.random() / 3) * (1 - j / W);
        drumBuffer2[parseInt(0.25 * pace) + j] += 0.02 * (saw(j / (80 - j / 2e3)) + Math.random() / 3) * (1 - j / W);
        drumBuffer2[parseInt(0.5 * pace) + j] += 0.06 * Math.random() * (1 - j / W) + 0.06 * (sin(j / (70 + j / 300)) + Math.random() / 3) * (1 - j / W);
        drumBuffer2[parseInt(0.75 * pace) + j] += 0.02 * (saw(j / (80 - j / 2e3)) + Math.random() / 3) * (1 - j / W);
      }
      await _yield();
      function bassNote(j, pitch) {
        const p = Math.pow(2, -pitch / 12) * 80;
        return 0.25 * sin(j / (p + j / 9e3)) * (1 - j / U);
      }
      const bassMusicBuffer = audioCtx.createBuffer(1, 16 * pace, sampleRate);
      const bassBuffer = bassMusicBuffer.getChannelData(0);
      const U = 0.25 * sampleRate;
      const bs = pace * 0.25;
      for (let o = 0; o < 4; o++) {
        const os = o * bs * 16;
        const br = [0, -5, -2, -7][o];
        for (let j = 0; j < U; j++) {
          bassBuffer[j + os] += bassNote(j, 0 + br);
          bassBuffer[j + bs * 3 + os] += bassNote(j, 5 + br);
          bassBuffer[j + bs * 4 + os] += bassNote(j, 7 + br);
          bassBuffer[j + bs * 5 + os] += bassNote(j, 10 + br);
          bassBuffer[j + bs * 7 + os] += bassNote(j, 12 + br);
          bassBuffer[j + bs * 9 + os] += bassNote(j, 12 + br);
          bassBuffer[j + bs * 10 + os] += bassNote(j, 10 + br);
          bassBuffer[j + bs * 11 + os] += bassNote(j, 7 + br);
          bassBuffer[j + bs * 12 + os] += bassNote(j, 12 + br);
          bassBuffer[j + bs * 14 + os] += bassNote(j, 10 + br);
        }
      }
      await _yield();
      function chordNote(j, pitch) {
        const p = Math.pow(2, -pitch / 12) * 20;
        return 0.04 * sin(j / (p + Math.exp(-j / U * 4) * 5)) * clamp(1 - j / (U * 12), 0, 1) * Math.pow(sin(j / 1550) * 0.5 + 0.5, 3);
      }
      const chordMusicBuffer = audioCtx.createBuffer(1, 16 * pace, sampleRate);
      const chordBuffer = chordMusicBuffer.getChannelData(0);
      for (let o = 0; o < 4; o++) {
        const os = o * bs * 16;
        const cr = [[-2, 3, 7], [-2, 2, 7], [-2, 2, 5], [-4, 0, 3]][o];
        for (let j = 0; j < U * 12; j++) {
          chordBuffer[j + os] += chordNote(j, cr[0]);
          chordBuffer[j + os] += chordNote(j, cr[1]);
          chordBuffer[j + os] += chordNote(j, cr[2]);
        }
      }
      await _yield();
      function leadNote(j, pitch) {
        const p = Math.pow(2, -pitch / 12) * 20;
        return 0.034 * saw(j / (p + sin(j / 1e3) * 0.01)) * (1 - j / (U * 2));
      }
      const leadMusicBuffer = audioCtx.createBuffer(1, 16 * pace, sampleRate);
      const leadBuffer = leadMusicBuffer.getChannelData(0);
      for (let j = 0; j < U * 2; j++) {
        leadBuffer[j] += leadNote(j, 7);
        leadBuffer[j + bs * 3] += leadNote(j, 0);
        leadBuffer[j + bs * 6] += leadNote(j, 3);
        leadBuffer[j + bs * 7] += leadNote(j, 5);
        leadBuffer[j + bs * 8] += leadNote(j, 7);
        leadBuffer[j + bs * 11] += leadNote(j, 0);
        leadBuffer[j + bs * 14] += leadNote(j, 3);
        leadBuffer[j + bs * 15] += leadNote(j, 5);
        leadBuffer[j + bs * 16] += leadNote(j, 2);
        leadBuffer[j + bs * 32] += leadNote(j, 5);
        leadBuffer[j + bs * (3 + 32)] += leadNote(j, -2);
        leadBuffer[j + bs * (6 + 32)] += leadNote(j, 2);
        leadBuffer[j + bs * (7 + 32)] += leadNote(j, 3);
        leadBuffer[j + bs * (8 + 32)] += leadNote(j, 5);
        leadBuffer[j + bs * (11 + 32)] += leadNote(j, -2);
        leadBuffer[j + bs * (14 + 32)] += leadNote(j, 3);
        leadBuffer[j + bs * (15 + 32)] += leadNote(j, 2);
        leadBuffer[j + bs * (16 + 32)] += leadNote(j, 0);
      }
      await _yield();
      musicBuffer = audioCtx.createBuffer(1, 8 * 4 * pace, sampleRate);
      const outBuffer = musicBuffer.getChannelData(0);
      for (let i = 0; i < outBuffer.length; i++) {
        outBuffer[i] += drumBuffer2[i % drumBuffer2.length];
        outBuffer[i] += bassBuffer[i % bassBuffer.length];
        outBuffer[i] += chordBuffer[i % chordBuffer.length];
        outBuffer[i] += leadBuffer[i % leadBuffer.length];
      }
      on(ENEMY_BONK, play(attackHitSound));
      on(ENEMY_TAKE_DAMAGE, play(attackHitSound));
      on(RUNESTONE_MOVE, play(runestoneMoveSound));
      on(RUNESTONE_LAND, play(runestoneLandedSound));
      on(POWERUP_ACQUIRED, play(powerupCollectSound));
      on(ENEMY_MOVE, play(enemyMoveSound));
      on(ENEMY_DAMAGE, play(enemySwordSound));
      on(ABILITY_BEAT, (t) => {
        play({
          0: fireSound,
          1: iceSound,
          2: zapSound
        }[t])();
      });
      on(SIGIL_DRAWN, ([type, dir]) => {
        play({
          0: sigilGarbage,
          5: sigilCaret,
          1: sigilCircle,
          3: sigilBolt,
          2: sigilTriangle,
          4: sigilWave,
          6: sigilHourglass
        }[type])();
      });
      gainNodeA = new GainNode(audioCtx);
      gainNodeA.connect(audioCtx.destination);
      gainNodeB = new GainNode(audioCtx);
      gainNodeB.connect(audioCtx.destination);
      music(musicBuffer);
    }
    async function genericSongBuilder([melodySignature, beat], seed, prog1, prog2) {
      const song = [];
      const drums = [];
      const noteLength = [4, 2, 0.5, 3, 4][seed];
      const noteSpace = [1, 0.5, 0.25, 2, 2][seed++];
      const bassNotes = [-15, -20, -19, -12];
      drums.push(
        [seed * seed * 3 * 0.5 % 2, seed % 2],
        [(seed * seed * 3 + seed * 9) * 0.5 % 2, (seed + 1) % 2],
        [(seed * seed * 2 + seed * 11) * 0.5 % 2, (seed + 1) % 2]
      );
      setProgress(prog1);
      for (let i = 0; i < 3; i++) {
        const o = i * 8;
        const q = [0, 3, -5][i];
        for (let j = 0; j < 8; j++) {
          song.push([bassNotes[(seed * 7 + i * 2 + (j >> 1) + j * j * 3) % 4] + q, j + o, 6, 1]);
        }
        for (let j = 0; j < 8 / noteSpace; j++) {
          if ((j + j * j + i + seed * 3) % 7 < 4) {
            song.push([-3 + q + melodySignature[(j + j * j * 2 + i * i * 2 + seed) % melodySignature.length], j * noteSpace + o, noteLength, 2]);
          }
        }
      }
      const targetBuffer = audioCtx.createBuffer(1, sampleRate * 8 * 3 * beat, sampleRate);
      const buffer = targetBuffer.getChannelData(0);
      for (let i = 0; i < song.length; i++) {
        let note, start, duration, amp;
        [note, start, duration, amp] = song[i];
        const baseIdx = parseInt(start * beat * sampleRate);
        const dur = duration * beat * sampleRate;
        for (let i2 = 0; i2 < dur; i2++) {
          let v = 0;
          const envelope = i2 / dur;
          v += amp == 1 ? clamp(sin(i2 / (6 * 2 ** (-note / 12) * 2 * 2) + sin(i2 / 8e3)) * (Math.exp(-envelope * 23) * 44 + 1), -1, 1) * 2 : saw(i2 / (4.03 * 6 * 2 ** (-note / 12) * 2)) * 7;
          buffer[baseIdx + i2] += v * Math.min(envelope * Math.exp(-envelope * (10 + amp * 7)) * 100, 1) / 500;
        }
        await _yield();
        setProgress(prog1 + (prog2 - prog1) * (i / song.length) * 0.8);
      }
      for (let q = 0; q < 44; q += 2) {
        for (let j = 0; j < drums.length; j++) {
          let type, drumStart;
          [drumStart, type] = drums[j];
          const noteOffset = parseInt(0.5 * sampleRate * type);
          const startOffset = parseInt((drumStart + q) * sampleRate * beat);
          for (let k = 0; k < sampleRate * 0.1; k++) {
            buffer[k + startOffset] += drumBuffer[k + noteOffset];
          }
        }
        await _yield();
        setProgress(prog1 + (prog2 - prog1) * (0.8 + 0.2 * (q / 44)));
      }
      return targetBuffer;
    }
    function play(audioBuffer) {
      return () => {
        let source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioCtx.destination);
        source.start();
      };
    }
    ;
    function music(musicBuffer2) {
      let audioToStop = activeMusicSource;
      activeMusicSource = audioCtx.createBufferSource();
      activeMusicSource.buffer = musicBuffer2;
      activeMusicSource.loop = true;
      activeMusicSource.connect(usingA ? gainNodeA : gainNodeB);
      activeMusicSource.start();
      setTimeout(() => {
        audioToStop?.stop();
      }, 700);
      gainNodeA.gain.setTargetAtTime(usingA ? 1 : 0, audioCtx.currentTime, 0.5);
      gainNodeB.gain.setTargetAtTime(usingA ? 0 : 1, audioCtx.currentTime, 0.5);
      usingA = !usingA;
    }
    return {
      init
    };
  }
  var audio_default = Audio;

  // src/main.js
  function initialize() {
    add(game_arena_default());
    add(wizard_default());
    add(rune_stone_default());
    add(spell_caster_default());
    add(enemy_spawner_default());
    function placePowerUp() {
      const powerType = Math.floor(Math.random() * 3);
      const shapeType = Math.floor(Math.random() * 5);
      for (let i = 0; i < 300; i++) {
        const sx = Math.floor(Math.random() * 4 + 1);
        const sy = Math.floor(Math.random() * 4 + 1);
        if (!spotOccupied(sx, sy)) {
          add(powerup_default(sx, sy, powerType, shapeType));
          return;
        }
      }
      console.log("Failed to place!");
    }
    placePowerUp();
    placePowerUp();
    placePowerUp();
    on(POWERUP_ACQUIRED, placePowerUp);
    audio_default().init();
  }
  initialize();
})();
</script>